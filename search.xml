<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker、Consul、Registrator和Traefik实现高可扩展Web框架</title>
    <url>/Docker%E3%80%81Consul%E3%80%81Registrator%E5%92%8CTraefik%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E6%89%A9%E5%B1%95Web%E6%A1%86%E6%9E%B6.html</url>
    <content><![CDATA[<h1 id="编者的话"><a href="#编者的话" class="headerlink" title="编者的话"></a>编者的话</h1><ul>
<li>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件，由 HashiCorp 公司用 Go 语言开发。本文将介绍如何使用 Consul 将多个 Docker 容器组合起来，提供一套高可用可扩展的 web 服务。</li>
<li>之前的话我尝试使用 Docker、consul、registrator、consul-temlate 和 haproxy 来管理我底层的 Docker 集群，并实现自动配置服务代理。但在一段使用过程以后，发现只要底层的 Docker 服务有增删的操作，都会重启 haproxy 代理服务，如果操作频繁的话有时会出现代理服务重启异常，导致所有的服务无法正常访问的现象。经过调研和尝试，发现 traefik 可以很好的避免这类现象的发生。</li>
</ul>
<h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><h2 id="1-服务器环境"><a href="#1-服务器环境" class="headerlink" title="1. 服务器环境"></a>1. 服务器环境</h2><table>
<thead>
<tr>
<th>主机名</th>
<th>IP地址</th>
<th>系统版本</th>
<th>docker版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>node1</td>
<td>192.168.0.2</td>
<td>Ubuntu14.04</td>
<td>1.12.3</td>
</tr>
<tr>
<td>node2</td>
<td>192.168.0.3</td>
<td>Ubuntu14.04</td>
<td>1.12.3</td>
</tr>
<tr>
<td>node3</td>
<td>192.168.0.4</td>
<td>Ubuntu14.04</td>
<td>1.12.3</td>
</tr>
</tbody>
</table>
<h2 id="2-registrator搭建"><a href="#2-registrator搭建" class="headerlink" title="2. registrator搭建"></a>2. registrator搭建</h2><p>使用 registartor 检测本地 docker 上所起的服务以及所暴露的端口，并注册到指定的 consul 机器上。</p>
<h3 id="registrator服务的部署"><a href="#registrator服务的部署" class="headerlink" title="registrator服务的部署"></a>registrator服务的部署</h3><p>node1 启动脚本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run -d --net=host --restart=always -v /var/run/docker.sock:/tmp/docker.sock --name registrator</span><br><span class="line">  gliderlabs/registrator:v7 \</span><br><span class="line">  -ip 192.168.0.2 \</span><br><span class="line">  consul://192.168.0.2:8500</span><br></pre></td></tr></table></figure>
<p>node2 启动脚本:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run -d --net=host --restart=always -v /var/run/docker.sock:/tmp/docker.sock --name registrator</span><br><span class="line">  gliderlabs/registrator:v7 \</span><br><span class="line">  -ip 192.168.0.3 \</span><br><span class="line">  consul://192.168.0.3:8500</span><br></pre></td></tr></table></figure></p>
<p>node3 启动脚本:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run -d --net=host --restart=always -v /var/run/docker.sock:/tmp/docker.sock --name registrator</span><br><span class="line">  gliderlabs/registrator:v7 \</span><br><span class="line">  -ip 192.168.0.4 \</span><br><span class="line">  consul://192/168.0.4:8500</span><br></pre></td></tr></table></figure></p>
<h2 id="3-Consul的搭建"><a href="#3-Consul的搭建" class="headerlink" title="3. Consul的搭建"></a>3. Consul的搭建</h2><p>Consul 是一个拥有 HTTP API 和 DNS 的服务，它还包括很多其他的功能如：服务健康检查、跨主机集群构建和”key-value”存储。</p>
<h3 id="Consul服务的部署"><a href="#Consul服务的部署" class="headerlink" title="Consul服务的部署"></a>Consul服务的部署</h3><p>node1 启动脚本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run -d --net=host --restart=always --name consul consul:v0.6.4 \</span><br><span class="line">  agent -server \</span><br><span class="line">  -node=node1 \</span><br><span class="line">  -client=192.168.0.2 \</span><br><span class="line">  -<span class="built_in">bind</span>=192.168.0.2 \</span><br><span class="line">  -retry-join=192.168.0.3 \</span><br><span class="line">  -retry-join=192.168.0.4</span><br></pre></td></tr></table></figure></p>
<p>node2 启动脚本:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run -d --net=host --restart=always --name consul consul:v0.6.4 \</span><br><span class="line">  agent -server \</span><br><span class="line">  -node=node2 \</span><br><span class="line">  -client=192.168.0.3 \</span><br><span class="line">  -<span class="built_in">bind</span>=192.168.0.3 \</span><br><span class="line">  -retry-join=192.168.0.2 \</span><br><span class="line">  -retry-join=192.168.0.4</span><br></pre></td></tr></table></figure></p>
<p>node3 启动脚本:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run -d --net=host --restart=always --name consul consul:v0.6.4 \</span><br><span class="line">  agent -server \</span><br><span class="line">  -node=node3 \</span><br><span class="line">  -client=192.168.0.4 \</span><br><span class="line">  -<span class="built_in">bind</span>=192.168.0.4 \</span><br><span class="line">  -retry-join=192.168.0.2 \</span><br><span class="line">  -retry-join=192.168.0.3</span><br></pre></td></tr></table></figure></p>
<h3 id="Consul-DNS配置"><a href="#Consul-DNS配置" class="headerlink" title="Consul DNS配置"></a>Consul DNS配置</h3><h4 id="配置DNS服务"><a href="#配置DNS服务" class="headerlink" title="配置DNS服务"></a>配置DNS服务</h4><p>最好在每台主机都配置上 DNS 服务。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install dnsmasq</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/dnsmasq.d/consul</span><br><span class="line"><span class="comment"># IP需要改为自己的本地IP</span></span><br><span class="line">server=/consul/192.168.0.2<span class="comment">#8600</span></span><br></pre></td></tr></table></figure>
<h4 id="修改Docker内部DNS"><a href="#修改Docker内部DNS" class="headerlink" title="修改Docker内部DNS"></a>修改Docker内部DNS</h4><p>修改 Docker 配置文件，将 DNS 指向新配置的 DNS 服务 IP。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/default/docker</span><br><span class="line">DOCKER_OPTS=<span class="string">" --storage-driver=aufs --dns=192.168.0.2"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="测试DNS服务"><a href="#测试DNS服务" class="headerlink" title="测试DNS服务"></a>测试DNS服务</h4><p>在集群任意一台服务器上起一个 redis 容器，启动时需要指定环境变量 “SERVER_NAME=redis”。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis -e SERVER_NAME=redis redis</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping redis.service.dc1.consul</span><br><span class="line">PING redis.service.dc1.consul (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from node1 (192.168.0.2): icmp_seq=1 ttl=64 time=0.021 ms</span><br><span class="line">64 bytes from node1 (192.168.0.2): icmp_seq=1 ttl=64 time=0.021 ms</span><br></pre></td></tr></table></figure>
<p>可以正确找到 redis 服务所在的服务器 IP 地址即可。</p>
<h2 id="4-traefik搭建"><a href="#4-traefik搭建" class="headerlink" title="4. traefik搭建"></a>4. traefik搭建</h2><h3 id="配置traefik服务"><a href="#配置traefik服务" class="headerlink" title="配置traefik服务"></a>配置traefik服务</h3><p>配置文件 traefik.toml，这里我选择放在 node1 服务器上。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># Global congifuration</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础设置</span></span><br><span class="line">graceTimeOut = 10</span><br><span class="line">logLevel = <span class="string">"INFO"</span></span><br><span class="line">insecureSkipVerify = <span class="literal">true</span></span><br><span class="line">defaultEntryPoints = [<span class="string">"http"</span>, <span class="string">"https"</span>]</span><br><span class="line">traefikLogsFile = <span class="string">"/var/log/traefik.log"</span></span><br><span class="line">accessLogsFile = <span class="string">"/var/log/access.log"</span></span><br><span class="line">errorLogsFile = <span class="string">"/var/log/error.log"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启http和https，这里的https证书使用的是 certbot(https://github.com/certbot/certbot) 生成的。</span></span><br><span class="line">[entryPoints]</span><br><span class="line"> [entryPoints.http]</span><br><span class="line"> address = <span class="string">":80"</span></span><br><span class="line"> [entryPoints.https]</span><br><span class="line"> address = <span class="string">":443"</span></span><br><span class="line">   [entryPoints.https.tls]</span><br><span class="line">	[[entryPoints.https.tls.certificates]]</span><br><span class="line">	CertFile = <span class="string">"/etc/ssl/live/www.zqifei.com/fullchain.pem"</span></span><br><span class="line">	KeyFile = <span class="string">"/etc/ssl/live/www.zqifei.com/privkey.pem"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我为traefik服务添加了域名：traefik.zqifei.com</span></span><br><span class="line">[file]</span><br><span class="line">[backends]</span><br><span class="line"> [backends.backend1]</span><br><span class="line">   [backends.backend1.circuitbreaker]</span><br><span class="line">     expression = <span class="string">"NetworkErrorRatio() &gt; 0.5"</span></span><br><span class="line">  [backends.backend1.maxconn]</span><br><span class="line">     amount = 10</span><br><span class="line">     extractorfunc = <span class="string">"request.host"</span></span><br><span class="line">  [backends.backend1.LoadBalancer]</span><br><span class="line">     method = <span class="string">"drr"</span></span><br><span class="line">  [backends.backend1.servers.server1]</span><br><span class="line">     url = <span class="string">"http://192.168.0.2:8080/"</span></span><br><span class="line"></span><br><span class="line">[frontends]</span><br><span class="line">    [frontends.frontend1]</span><br><span class="line">    backend = <span class="string">"backend1"</span></span><br><span class="line">    entrypoints = [<span class="string">"http"</span>, <span class="string">"https"</span>]</span><br><span class="line">       [frontends.frontend1.routes.zqifei]</span><br><span class="line">       rule = <span class="string">"Host:traefik.zqifei.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># web端访问服务的端口号</span></span><br><span class="line">[web]</span><br><span class="line">address = <span class="string">":8080"</span></span><br><span class="line">ReadOnly = <span class="literal">false</span></span><br><span class="line"> [web.statistics]</span><br><span class="line">    RecentErrors = 10</span><br><span class="line">    [web.auth.basic]</span><br><span class="line">       users = [<span class="string">"zhuqifei:<span class="variable">$1</span><span class="variable">$4K</span>.YXlm1<span class="variable">$IkFqpMv6Vh7Yro4Qj5HUB1</span>"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># consul节点及域名，这里需要将 *.zqifei.com 域名指定到部署traefik这台主机上。</span></span><br><span class="line">[consul]</span><br><span class="line">  endpoint = <span class="string">"192.168.0.2:8500"</span></span><br><span class="line">  domain = <span class="string">"zqifei.com"</span></span><br><span class="line">  watch = <span class="literal">true</span></span><br><span class="line">  prefix = <span class="string">"traefik"</span></span><br><span class="line"></span><br><span class="line">[consulCatalog]</span><br><span class="line">  endpoint = <span class="string">"192.168.0.2:8500"</span></span><br><span class="line">  domain = <span class="string">"zqifei.com"</span></span><br><span class="line">  prefix = <span class="string">"traefik"</span></span><br></pre></td></tr></table></figure></p>
<p>启动脚本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_run</span></span>() &#123;</span><br><span class="line">  docker run --restart=always -d -p 8080:8080 -p 80:80 -p 443:443 --name traefik \</span><br><span class="line">  -v <span class="variable">$PWD</span>/traefik.toml:/etc/traefik/traefik.toml \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v /data/volumes/traefik:/var/<span class="built_in">log</span> \</span><br><span class="line">  -v /etc/letsencrypt:/etc/ssl \</span><br><span class="line">  traefik:v1.2.3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NAME=`docker ps -a | grep traefik | awk <span class="string">'&#123;print $NF&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$NAME</span>"</span> = <span class="string">"traefik"</span> ]; <span class="keyword">then</span></span><br><span class="line">  docker rm -f traefik;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"traefik have delete!"</span>;</span><br><span class="line">  docker_run;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"traefik start running!"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"traefik not running!"</span>;</span><br><span class="line">  docker_run;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"traefik start running!"</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<h3 id="traefik界面访问"><a href="#traefik界面访问" class="headerlink" title="traefik界面访问"></a>traefik界面访问</h3><p>通过浏览器访问 <a href="https://traefik.zqifei.com" target="_blank" rel="noopener">https://traefik.zqifei.com</a> (记得将域名解析到代理服务器上)会出现账号密码验证，输入在配置文件设置的密码即可登录进去。更多 traefik 配置请参考 <a href="https://docs.traefik.io/" target="_blank" rel="noopener">traefik官方文档</a>。<br><img src="http://cdn.zqifei.com/20170924150626425397349.png" alt="20170924150626425397349.png"></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署gitlab</title>
    <url>/Docker%E9%83%A8%E7%BD%B2gitlab.html</url>
    <content><![CDATA[<h2 id="下载指定版本的gitlab镜像"><a href="#下载指定版本的gitlab镜像" class="headerlink" title="下载指定版本的gitlab镜像"></a>下载指定版本的gitlab镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull gitlab/gitlab-ce:9.3.4-ce.0</span><br></pre></td></tr></table></figure>
<h2 id="使用docker启动gitlab"><a href="#使用docker启动gitlab" class="headerlink" title="使用docker启动gitlab"></a>使用docker启动gitlab</h2><p>添加 gitlab 启动脚本 gitlab.sh 。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run -d --restart=always \</span><br><span class="line">   -p 8443:443 \</span><br><span class="line">   -p 8080:80 \</span><br><span class="line">   -p 22:22 \</span><br><span class="line">   --name gitlab \</span><br><span class="line">   -v /data/volumes/gitlab/config:/etc/gitlab \</span><br><span class="line">   -v /data/volumes/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line">   -v /data/volumes/gitlab/data:/var/opt/gitlab \</span><br><span class="line">   gitlab/gitlab-ce:9.3.4-ce.0</span><br></pre></td></tr></table></figure></p>
<h2 id="修改-gitlab-配置文件"><a href="#修改-gitlab-配置文件" class="headerlink" title="修改 gitlab 配置文件"></a>修改 gitlab 配置文件</h2><p>配置文件位置为: /data/volumes/gitlab/config/gitlab.rb 。<br>该配置文件添加了邮箱、数据备份、ldap、外部nginx 和 gitlab pages 的配置。<br><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gitlab 外部URL</span></span><br><span class="line">external_url <span class="string">'https://git.zqifei.com'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开启ldap服务</span></span><br><span class="line">gitlab_rails[<span class="string">'ldap_enabled'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'ldap_servers'</span>] = YAML.load &lt;&lt;-<span class="string">'EOS'</span></span><br><span class="line">  <span class="symbol">main:</span> <span class="comment"># 'main' is the GitLab 'provider ID' of this LDAP server</span></span><br><span class="line">    <span class="symbol">label:</span> <span class="string">'LDAP'</span></span><br><span class="line">    <span class="symbol">host:</span> <span class="string">'ldap-server'</span></span><br><span class="line">    <span class="symbol">port:</span> <span class="number">389</span></span><br><span class="line">    <span class="symbol">uid:</span> <span class="string">'uid'</span></span><br><span class="line">    <span class="symbol">method:</span> <span class="string">'plain'</span> <span class="comment"># "tls" or "ssl" or "plain"</span></span><br><span class="line">    <span class="symbol">bind_dn:</span> <span class="string">'cn=admin,dc=zqifei,dc=com'</span></span><br><span class="line">    <span class="symbol">base:</span> <span class="string">'cn=user,dc=zqifei,dc=com'</span></span><br><span class="line">    <span class="symbol">password:</span> <span class="string">'ldap-password'</span></span><br><span class="line">    <span class="symbol">active_directory:</span> <span class="literal">true</span></span><br><span class="line">    <span class="symbol">allow_username_or_email_login:</span> <span class="literal">true</span></span><br><span class="line">    <span class="symbol">block_auto_created_users:</span> <span class="literal">false</span></span><br><span class="line">    <span class="symbol">user_filter:</span> <span class="string">''</span></span><br><span class="line">    <span class="symbol">attributes:</span></span><br><span class="line">      <span class="symbol">username:</span> <span class="string">'uid'</span></span><br><span class="line">      <span class="symbol">email:</span>    <span class="string">'email'</span></span><br><span class="line">      <span class="symbol">name:</span>     <span class="string">'cn'</span></span><br><span class="line">      <span class="symbol">last_name:</span> <span class="string">'sn'</span></span><br><span class="line">EOS</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gitlab 备份数据到AWS S3上</span></span><br><span class="line">gitlab_rails[<span class="string">'backup_keep_time'</span>] = <span class="number">604800</span></span><br><span class="line">gitlab_rails[<span class="string">'backup_upload_connection'</span>] = &#123;</span><br><span class="line"> <span class="string">'provider'</span> =&gt; <span class="string">'AWS'</span>,</span><br><span class="line"> <span class="string">'region'</span> =&gt; <span class="string">'you_aws_region'</span>,</span><br><span class="line"> <span class="string">'aws_access_key_id'</span> =&gt; <span class="string">'you_aws_key_id'</span>,</span><br><span class="line"> <span class="string">'aws_secret_access_key'</span> =&gt; <span class="string">'you_aws_access_key'</span></span><br><span class="line">&#125;</span><br><span class="line">gitlab_rails[<span class="string">'backup_upload_remote_directory'</span>] = <span class="string">'you_awk_bucket'</span></span><br><span class="line">gitlab_rails[<span class="string">'backup_multipart_chunk_size'</span>] = <span class="number">104857600</span></span><br><span class="line">gitlab_rails[<span class="string">'gitlab_shell_ssh_port'</span>] = <span class="number">22</span>   <span class="comment">#需要跟启动脚本的ssh端口对应</span></span><br><span class="line">  </span><br><span class="line">gitlab_rails[<span class="string">'rack_attack_git_basic_auth'</span>] = &#123;</span><br><span class="line"> <span class="string">'enabled'</span> =&gt; <span class="literal">false</span>,</span><br><span class="line"> <span class="string">'ip_whitelist'</span> =&gt; [<span class="string">"127.0.0.1"</span>],</span><br><span class="line"> <span class="string">'maxretry'</span> =&gt; <span class="number">10</span>,</span><br><span class="line"> <span class="string">'findtime'</span> =&gt; <span class="number">60</span>,</span><br><span class="line"> <span class="string">'bantime'</span> =&gt; <span class="number">3600</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gitlab 邮箱配置</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_enable'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_address'</span>] = <span class="string">"you_smtp_address"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_port'</span>] = <span class="number">25</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_user_name'</span>] = <span class="string">"you_smtp_user_name"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_password'</span>] = <span class="string">"you_smtp_password"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_domain'</span>] = <span class="string">"you_smtp_domain"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_authentication'</span>] = <span class="string">"login"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_enable_starttls_auto'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_tls'</span>] = <span class="literal">false</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_openssl_verify_mode'</span>] = <span class="string">'none'</span></span><br><span class="line">gitlab_rails[<span class="string">'gitlab_email_from'</span>] = <span class="string">"send_from_email_address"</span></span><br><span class="line">user[<span class="string">'git_user_email'</span>] = <span class="string">"use_email"</span></span><br><span class="line">unicorn[<span class="string">'worker_timeout'</span>] = <span class="number">60</span></span><br><span class="line">unicorn[<span class="string">'worker_processes'</span>] = <span class="number">2</span></span><br><span class="line">sidekiq[<span class="string">'concurrency'</span>] = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 关闭gitlab内部nginx</span></span><br><span class="line">nginx[<span class="string">'enable'</span>] = <span class="literal">false</span></span><br><span class="line">web_server[<span class="string">'external_users'</span>] = [<span class="string">'www-data'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开启gitlab pages服务</span></span><br><span class="line">pages_external_url <span class="string">"http://pages.zqifei.com/"</span></span><br><span class="line">gitlab_pages[<span class="string">'enable'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_pages[<span class="string">'external_http'</span>] = <span class="string">"pages.zqifei.com"</span></span><br><span class="line">gitlab_pages[<span class="string">'redirect_http'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_pages[<span class="string">'dir'</span>] = <span class="string">"/var/opt/gitlab/gitlab-pages"</span></span><br><span class="line">gitlab_pages[<span class="string">'log_directory'</span>] = <span class="string">"/var/log/gitlab/gitlab-pages"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用外部nginx代理gitlab服务"><a href="#使用外部nginx代理gitlab服务" class="headerlink" title="使用外部nginx代理gitlab服务"></a>使用外部nginx代理gitlab服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /etc/nginx/conf.d/gitlab.conf</span><br><span class="line"></span><br><span class="line">upstream gitlab-workhorse &#123;</span><br><span class="line">  server unix:/data/volumes/gitlab/data/gitlab-workhorse/socket fail_timeout=0;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">## Redirects all HTTP traffic to the HTTPS host</span><br><span class="line">server &#123;</span><br><span class="line">  ## Either remove &quot;default_server&quot; from the listen line below,</span><br><span class="line">  ## or delete the /etc/nginx/sites-enabled/default file. This will cause gitlab</span><br><span class="line">  ## to be served if you visit any address that your server responds to, eg.</span><br><span class="line">  ## the ip address of the server (http://x.x.x.x/)</span><br><span class="line">  listen 80;</span><br><span class="line">  listen [::]:80;</span><br><span class="line">  server_name git.zqifei.com; ## Replace this with something like gitlab.example.com</span><br><span class="line">  server_tokens off; ## Don&apos;t show the nginx version number, a security best practice</span><br><span class="line">  return 301 https://$http_host$request_uri;</span><br><span class="line">  access_log  /var/log/nginx/gitlab_access.log;</span><br><span class="line">  error_log   /var/log/nginx/gitlab_error.log;</span><br><span class="line">&#125;</span><br><span class="line">## HTTPS host</span><br><span class="line">server &#123;</span><br><span class="line">  listen 0.0.0.0:443 ssl;</span><br><span class="line">  listen [::]:443 ipv6only=on ssl default_server;</span><br><span class="line">  server_name git.zqifei.com; ## Replace this with something like gitlab.example.com</span><br><span class="line">  server_tokens off; ## Don&apos;t show the nginx version number, a security best practice</span><br><span class="line">  root /data/volumes/gitlab/public;</span><br><span class="line">    </span><br><span class="line">  ## Strong SSL Security</span><br><span class="line">  ## https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html &amp; https://cipherli.st/</span><br><span class="line">  ssl on;</span><br><span class="line">  ssl_certificate /etc/nginx/ssl/git.zqifei.com.crt;</span><br><span class="line">  ssl_certificate_key /etc/nginx/ssl/git.zqifei.com.key;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">  # GitLab needs backwards compatible ciphers to retain compatibility with Java IDEs</span><br><span class="line">  ssl_ciphers &quot;ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4&quot;;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line">  ssl_session_cache shared:SSL:10m;</span><br><span class="line">  ssl_session_timeout 5m;</span><br><span class="line">  </span><br><span class="line">  ## See app/controllers/application_controller.rb for headers set</span><br><span class="line">  ## [Optional] Enable HTTP Strict Transport Security</span><br><span class="line">  ## HSTS is a feature improving protection against MITM attacks</span><br><span class="line">  ## For more information see: https://www.nginx.com/blog/http-strict-transport-security-hsts-and-nginx/</span><br><span class="line">  # add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot;;</span><br><span class="line"> </span><br><span class="line">  ## [Optional] If your certficate has OCSP, enable OCSP stapling to reduce the overhead and latency of running SSL.</span><br><span class="line">  ## Replace with your ssl_trusted_certificate. For more info see:</span><br><span class="line">  ## - https://medium.com/devops-programming/4445f4862461</span><br><span class="line">  ## - https://www.ruby-forum.com/topic/4419319</span><br><span class="line">  ## - https://www.digitalocean.com/community/tutorials/how-to-configure-ocsp-stapling-on-apache-and-nginx</span><br><span class="line">  # ssl_stapling on;</span><br><span class="line">  # ssl_stapling_verify on;</span><br><span class="line">  # ssl_trusted_certificate /etc/nginx/ssl/stapling.trusted.crt;</span><br><span class="line">  # resolver 208.67.222.222 208.67.222.220 valid=300s; # Can change to your DNS resolver if desired</span><br><span class="line">  # resolver_timeout 5s;</span><br><span class="line"> </span><br><span class="line">  ## [Optional] Generate a stronger DHE parameter:</span><br><span class="line">  ##   sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 4096</span><br><span class="line">  ##</span><br><span class="line">  # ssl_dhparam /etc/ssl/certs/dhparam.pem;</span><br><span class="line"> </span><br><span class="line">  ## Individual nginx logs for this GitLab vhost</span><br><span class="line">  access_log  /var/log/nginx/gitlab_access.log;</span><br><span class="line">  error_log   /var/log/nginx/gitlab_error.log;</span><br><span class="line">   </span><br><span class="line">  location / &#123;</span><br><span class="line">    client_max_body_size 0;</span><br><span class="line">    gzip off;</span><br><span class="line"> </span><br><span class="line">    ## https://github.com/gitlabhq/gitlabhq/issues/694</span><br><span class="line">    ## Some requests take more than 30 seconds.</span><br><span class="line">    proxy_read_timeout      300;</span><br><span class="line">    proxy_connect_timeout   300;</span><br><span class="line">    proxy_redirect          off;</span><br><span class="line"> </span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line"> </span><br><span class="line">    proxy_set_header    Host                $http_host;</span><br><span class="line">    proxy_set_header    X-Real-IP           $remote_addr;</span><br><span class="line">    proxy_set_header    X-Forwarded-Ssl     on;</span><br><span class="line">    proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header    X-Forwarded-Proto   $scheme;</span><br><span class="line">    proxy_pass http://gitlab-workhorse;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gitlab目录权限配置"><a href="#gitlab目录权限配置" class="headerlink" title="gitlab目录权限配置"></a>gitlab目录权限配置</h3><p>在使用外部 nginx 时，gitlab 外挂到主机的目录权限需要进行修改，否则启动 gitlab 以后访问会报 404 。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ usermod -aG docker www-data</span><br><span class="line">$ setfacl -R -m user::rex /data/volumes/gitlab</span><br><span class="line">$ setfacl -R -m group::rwx /data/volumes/gitlab</span><br><span class="line">$ setfacl -R -m group::rwx /data/volumes/gitlab</span><br></pre></td></tr></table></figure></p>
<h2 id="恢复gitlab备份数据"><a href="#恢复gitlab备份数据" class="headerlink" title="恢复gitlab备份数据"></a>恢复gitlab备份数据</h2><p>将备份的数据传到容器内。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker cp 1393513186_gitlab_backup.tar gitlab:/var/opt/gitlab/backups/</span><br></pre></td></tr></table></figure></p>
<p>停止相关数据连接服务。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gitlab-ctl stop unicorn</span><br><span class="line">$ gitlab-ctl stop sidekiq</span><br></pre></td></tr></table></figure></p>
<p>从 1393513186 编号中备份恢复。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gitlab-rake gitlab:backup:restore BACKUP=1393513186</span><br></pre></td></tr></table></figure></p>
<p>启动 gitlab 服务。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gitlab-ctl start</span><br></pre></td></tr></table></figure></p>
<h2 id="添加定时任务"><a href="#添加定时任务" class="headerlink" title="添加定时任务"></a>添加定时任务</h2><p>在服务器上添加 crontab 任务，定时备份数据传到 AWS S3 上。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 2 * * * docker <span class="built_in">exec</span> gitlab gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure></p>
<h2 id="部署gitlab-runner"><a href="#部署gitlab-runner" class="headerlink" title="部署gitlab runner"></a>部署gitlab runner</h2><p>下载 gitlab-runner 镜像。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull gitlab/gitlab-runner:v9.3.0</span><br></pre></td></tr></table></figure></p>
<p>启动脚本。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line"> -v /data/volumes/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line"> -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line"> gitlab/gitlab-runner:v9.3.0</span><br></pre></td></tr></table></figure></p>
<h3 id="注册gitlab-runner"><a href="#注册gitlab-runner" class="headerlink" title="注册gitlab runner"></a>注册gitlab runner</h3><p>进入 gitlab runner 容器内执行注册命令。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it gitlab-runner bash</span><br><span class="line">$ gitlab-runner register</span><br><span class="line">1. 输入gitlab地址</span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://git.zqifei.com</span><br><span class="line">  </span><br><span class="line">2. gitlab的token(在gitlab的Admin Area中)或者仓库的token(仓库-&gt;设置-&gt;Runner)</span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line">***</span><br><span class="line">  </span><br><span class="line">3. gitlab Runner描述信息</span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner</span><br><span class="line">[hostame] my-runner</span><br><span class="line">  </span><br><span class="line">4. gitlab Runner的标签 可以指定仓库 只使用固定标签的Runner构建</span><br><span class="line">Please enter the gitlab-ci tags <span class="keyword">for</span> this runner (comma separated):</span><br><span class="line">docker</span><br><span class="line">  </span><br><span class="line">5. 选择 runner 是否运行未标记的工作</span><br><span class="line">Whether to run untagged <span class="built_in">jobs</span> [<span class="literal">true</span>/<span class="literal">false</span>]:</span><br><span class="line">[<span class="literal">false</span>]: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">6. 选择是否锁定当前项目的运行程序</span><br><span class="line">Whether to lock Runner to current project [<span class="literal">true</span>/<span class="literal">false</span>]:</span><br><span class="line">[<span class="literal">false</span>]: <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">7. 输入执行程序</span><br><span class="line">Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:</span><br><span class="line">docker</span><br><span class="line">  </span><br><span class="line">8. 选择编译的环境</span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">alpine:latest</span><br></pre></td></tr></table></figure></p>
<p>查看已经注册的 runner。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gitlab-runner list</span><br></pre></td></tr></table></figure></p>
<p>注册成功后就可以在 gitlab 的页面查看到 ranner 了。</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LDAP安装配置</title>
    <url>/LDAP%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h2 id="1-安装-LDAP"><a href="#1-安装-LDAP" class="headerlink" title="1.安装 LDAP"></a>1.安装 LDAP</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install slapd ldap-utils</span><br></pre></td></tr></table></figure>
<p>安装过程会提示设置LDAP管理员账号密码：</p>
<p><img src="http://cdn.zqifei.com/20170906150466346771942.png" alt="20170906150466346771942.png"></p>
<p>再次确认密码：</p>
<p><img src="http://cdn.zqifei.com/20170906150466350381346.png" alt="20170906150466350381346.png"></p>
<h2 id="2-配置-LDAP"><a href="#2-配置-LDAP" class="headerlink" title="2.配置 LDAP"></a>2.配置 LDAP</h2><p>打开 <code>/etc/ldap/ldap.conf</code> 文件。安装以下内容进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/ldap/ldap.conf</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LDAP Defaults</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See ldap.conf(5) for details</span></span><br><span class="line"><span class="comment"># This file should be world readable but not world writeable.</span></span><br><span class="line"></span><br><span class="line">BASE   dc=domain.com,dc=com</span><br><span class="line">URL    ldap://:389</span><br><span class="line"></span><br><span class="line"><span class="comment">#SIZELIMIT      12</span></span><br><span class="line"><span class="comment">#TIMELIMIT      15</span></span><br><span class="line"><span class="comment">#DEREF          never</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TLS certificates (needed for GnuTLS)</span></span><br><span class="line">TLS_CACERT      /etc/ssl/certs/ca-certificates.crt</span><br></pre></td></tr></table></figure>
<p>执行以下命令进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dpkg-reconfigure slapd</span><br></pre></td></tr></table></figure>
<p>以下界面选择 “NO” 后按Enter继续:</p>
<p><img src="http://cdn.zqifei.com/2017090615046636189543.png" alt="2017090615046636189543.png"></p>
<p>输入DNS domain名称：</p>
<p><img src="http://cdn.zqifei.com/20170906150466894882341.png" alt="20170906150466894882341.png"></p>
<p>输入组织名称:</p>
<p><img src="http://cdn.zqifei.com/20170906150466902698347.png" alt="20170906150466902698347.png"></p>
<p>输入LDAP管理员密码:</p>
<p><img src="http://cdn.zqifei.com/20170906150466369835125.png" alt="20170906150466369835125.png"></p>
<p>再次确认LDAP管理员密码:</p>
<p><img src="http://cdn.zqifei.com/20170906150466372510553.png" alt="20170906150466372510553.png"></p>
<p>选择HDB数据库:</p>
<p><img src="http://cdn.zqifei.com/2017090615046637432197.png" alt="2017090615046637432197.png"></p>
<p>选择删除LDAP服务时自动删除数据库:</p>
<p><img src="http://cdn.zqifei.com/20170906150466377023274.png" alt="20170906150466377023274.png"></p>
<p>选择删除之前的数据库:</p>
<p><img src="http://cdn.zqifei.com/20170906150466379288300.png" alt="20170906150466379288300.png"></p>
<p>选择 “No” 后，LDAP服务配置完成并启动。</p>
<p><img src="http://cdn.zqifei.com/2017090615046638157804.png" alt="2017090615046638157804.png"></p>
<h3 id="3-测试LDAP服务"><a href="#3-测试LDAP服务" class="headerlink" title="3.测试LDAP服务"></a>3.测试LDAP服务</h3><p>输入 <code>ldapsearch -x</code> 会看到以下输出:</p>
<p><img src="http://cdn.zqifei.com/20170906150466917589335.png" alt="20170906150466917589335.png"></p>
<h3 id="4-修改LDAP配置"><a href="#4-修改LDAP配置" class="headerlink" title="4.修改LDAP配置"></a>4.修改LDAP配置</h3><p>拷贝DB_CONFIG 和 slapd.conf两个文件到 /var/lib/ldap 和 /etc/ldap 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp -rp /usr/share/slapd/DB_CONFIG /var/lib/slapd/</span><br><span class="line">$ cp -rp /usr/share/slapd/slapd.conf /etc/ldap/</span><br></pre></td></tr></table></figure>
<p>修改rsync.conf记录ldap日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"local4.debug   /var/log/ldap.log"</span> &gt;&gt; /etc/rsyslog.conf</span><br><span class="line">$ /etc/init.d/rsyslog restart</span><br></pre></td></tr></table></figure>
<p>修改配置文件/etc/ldap/slapd.conf</p>
<p><img src="http://cdn.zqifei.com/20170808150216644151461.png" alt="20170808150216644151461.png"></p>
<p><img src="http://cdn.zqifei.com/20170808150216650616321.png" alt="20170808150216650616321.png"></p>
<p><img src="http://cdn.zqifei.com/20170906150466927049313.png" alt="20170906150466927049313.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注意密码是通过slappasswd生成的（例如使用的是123456作为密码）</span><br><span class="line">root@ldap:/etc/ldap<span class="comment"># slappasswd -h &#123;md5&#125;      </span></span><br><span class="line">New password:</span><br><span class="line">Re-enter new password:</span><br><span class="line">&#123;MD5&#125;lk1phaN9bHwNex19prBWCA==</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.zqifei.com/20170808150216679075860.png" alt="20170808150216679075860.png"></p>
<p><img src="http://cdn.zqifei.com/201709061504669315253.png" alt="201709061504669315253.png"></p>
<p>生成新的 slapd.d 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/ldap/</span><br><span class="line">$ rm -rf slapd.d</span><br><span class="line">$ mkdir slapd.d</span><br><span class="line">$ slaptest -f slapd.conf  -F slapd.d</span><br><span class="line">$ chown -R openldap slapd.d （改变新生成的slapd.d属主）</span><br><span class="line">$ service slapd restart</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible基础篇 - Ansible介绍</title>
    <url>/Ansible%E5%9F%BA%E7%A1%80%E7%AF%87%20-%20Ansible%E4%BB%8B%E7%BB%8D.html</url>
    <content><![CDATA[<h2 id="一、什么是Ansible"><a href="#一、什么是Ansible" class="headerlink" title="一、什么是Ansible?"></a>一、什么是Ansible?</h2><p>1、基于Python开发的一个自动化运维工具。</p>
<p>2、可以批量的管理远程的主机，实现批量部署服务、执行命令等。</p>
<p>3、基于模块化来工作，提供了很高的扩展性。</p>
<p>4、基于SSH协议。</p>
<h2 id="二、Ansible-名字的由来"><a href="#二、Ansible-名字的由来" class="headerlink" title="二、Ansible 名字的由来?"></a>二、Ansible 名字的由来?</h2><p>Ansible 取名自知名小说 &lt;&lt;安德的游戏&gt;&gt;（Ender’s Game），并且这部小说在2013年被改编成电影，2014年1月7号在中国上映。</p>
<p>在电影中，安塞波（Ansible）是虚构的一种以超光速传递信息的通讯装置，片中主角安德（Ender）和他的伙伴们通过安塞波（Ansible）跨越时空指挥无数的战舰，就好比我们控制海量的远端服务器一样。</p>
<p><img src="http://cdn.zqifei.com/20200817159765285241685.png" alt="20200817159765285241685.png"></p>
<h2 id="三、Ansible-能做什么？"><a href="#三、Ansible-能做什么？" class="headerlink" title="三、Ansible 能做什么？"></a>三、Ansible 能做什么？</h2><p>电影中的 Ansible 是用来控制战舰，消灭敌人的。那么我们服务器上的 Ansible 可以做些什么呢？</p>
<p>我们通过查看 Ansible 的模块可知，它几乎支持数据中心的一切自动化，包括（不限于）</p>
<p><code>操作系统层面</code>：从 Linux（物理机、虚拟机、云环境），Unix，到 Windows。</p>
<p><code>虚拟化平台</code>：VMware、Docker、Cloudstack、LXC、Openstack 等。</p>
<p><code>商业化硬件</code>：F5、ASA、Citrix、Eos 以及各种服务器设备的管理。</p>
<p><code>系统应用层</code>：Apache、Zabbix、RabbitMQ、SVN、GIT 等。</p>
<p><code>红帽解决方案</code>：Openshift、Ceph、GlusterFS 等，支持几乎所有红帽解决方案的一键部署和配置。</p>
<p><code>云平台</code>： IBM Cloud 、AWS、Azure、Cloudflare、Red Hat CloudForms、Google、Linode、Digital Ocean 等。</p>
<h2 id="四、Ansible-的优点"><a href="#四、Ansible-的优点" class="headerlink" title="四、Ansible 的优点"></a>四、Ansible 的优点</h2><p> 1、轻量级，远端主机无需安装任何依赖。</p>
<p> 2、易读性，playbook 基于 YAML 开发的，而 YAML 是一种易于人类读写的数据格式语言。</p>
<p> 3、使用 python 编写，维护更简单。</p>
<p> 4、内置上千个模块，可以满足我们工作中绝大多数的需求。</p>
<p> 5、开源社区活跃。</p>
<h2 id="五、Ansible-包含哪些组件？"><a href="#五、Ansible-包含哪些组件？" class="headerlink" title="五、Ansible 包含哪些组件？"></a>五、Ansible 包含哪些组件？</h2><p>Ansible 的核心组件包括：</p>
<ul>
<li>Modules(模块)<blockquote>
<p>Modules 是 Ansible 的核心资产，有了 Modules , 我们才能调用这些 Modules 来完成我们想要执行的自动化任务。</p>
</blockquote>
</li>
</ul>
<ul>
<li>Inventory（管理对象的清单）<blockquote>
<p>Inventory 是 Ansible 要管理对象的清单。在清单中，可以配置分组、主机信息等。</p>
</blockquote>
</li>
</ul>
<ul>
<li>Playbook（任务编排）<blockquote>
<p>任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YAML文件。</p>
</blockquote>
</li>
</ul>
<ul>
<li>Roles(编排Playbook) <blockquote>
<p>Roles 是将 Playbook 分成多个文件的主要机制。这简化了编写复杂的 Playbook，并使其更易于重用。通过 Roles 可以将 Playbook 分解为可重用的组件。</p>
</blockquote>
</li>
</ul>
<ul>
<li>Plugins（插件）<blockquote>
<p>Plugins 是增强 Ansible 核心功能的代码。Ansible 附带了许多方便的插件，如果这些插件不够，我们可以编写自己的插件。Ansible 自带的 Plugins 如下图所示：<br><img src="http://cdn.zqifei.com/20200817159765188699497.png" alt="20200817159765188699497.png"></p>
</blockquote>
</li>
</ul>
<h2 id="六、Ansible-如何运作？"><a href="#六、Ansible-如何运作？" class="headerlink" title="六、Ansible 如何运作？"></a>六、Ansible 如何运作？</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://cdn.zqifei.com/20200817159765293893463.png" alt="20200817159765293893463.png"></p>
<h2 id="七、Ansible-代码仓库及文档"><a href="#七、Ansible-代码仓库及文档" class="headerlink" title="七、Ansible 代码仓库及文档"></a>七、Ansible 代码仓库及文档</h2><p>Ansible 的代码仓库存放在 Github 上，仓库地址为：<a href="https://github.com/ansible/ansible" target="_blank" rel="noopener">https://github.com/ansible/ansible</a> 。</p>
<p>Ansible 官方文档地址为：<a href="https://docs.ansible.com/ansible/latest/index.html。" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/index.html。</a></p>
]]></content>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible基础篇 - Ansible用法</title>
    <url>/Ansible%E5%9F%BA%E7%A1%80%E7%AF%87%20-%20Ansible%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="一、Ansible-安装"><a href="#一、Ansible-安装" class="headerlink" title="一、Ansible 安装"></a>一、Ansible 安装</h2><ul>
<li><p>管理员节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ # Redhat/CentOS Linux上，Ansible目前放在的epel源中</span><br><span class="line">$ # Fedora默认源中包含ansible，直接安装包既可</span><br><span class="line"></span><br><span class="line">$ sudo yum install epel-release </span><br><span class="line">$ sudo yum install ansible -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>被管理节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不需要安装特殊的包，只需要python&gt;2.4，RedHat Linux一般安装方式都是默认安装的。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、Ansible-配置文件"><a href="#二、Ansible-配置文件" class="headerlink" title="二、Ansible 配置文件"></a>二、Ansible 配置文件</h2><h3 id="ansible-cfg-配置文件作用"><a href="#ansible-cfg-配置文件作用" class="headerlink" title="ansible.cfg 配置文件作用"></a>ansible.cfg 配置文件作用</h3><p>可以用来定义默认连接用户、端口号，优化连接速度等等。</p>
<p>ansible 配置文件不同段详解：<a href="http://www.ansible.com.cn/docs/intro_configuration.html#config-values-by-section" target="_blank" rel="noopener">http://www.ansible.com.cn/docs/intro_configuration.html#config-values-by-section</a></p>
<h3 id="ansible-cfg-配置文件优化模板"><a href="#ansible-cfg-配置文件优化模板" class="headerlink" title="ansible.cfg 配置文件优化模板"></a>ansible.cfg 配置文件优化模板</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==============================================</span></span><br><span class="line"><span class="comment"># Desc: config file for ansible</span></span><br><span class="line"><span class="comment"># Website: http://ansible.com/</span></span><br><span class="line"><span class="comment"># Doc: http://docs.ansible.com/ansible/intro_configuration.html</span></span><br><span class="line"></span><br><span class="line"><span class="string">[defaults]</span></span><br><span class="line"><span class="string">forks</span>             <span class="string">=</span> <span class="number">50</span>             <span class="comment"># 设置在与主机通信时的默认并行进程数</span></span><br><span class="line"><span class="string">ask_sudo_pass</span>     <span class="string">=</span> <span class="literal">False</span>          <span class="comment"># 用来控制ansible playbook 在执行sudo之前是否询问sudo密码。默认为no</span></span><br><span class="line"><span class="string">ask_pass</span>          <span class="string">=</span> <span class="literal">False</span>          <span class="comment"># 控制ansible playbook 是否会自动默认弹出密码。默认为no</span></span><br><span class="line"><span class="string">remote_port</span>       <span class="string">=</span> <span class="number">22</span>             <span class="comment"># 系统默认的远程SSH端口，默认是22端口。</span></span><br><span class="line"><span class="string">module_lang</span>       <span class="string">=</span> <span class="string">en_US.UTF-8</span>    <span class="comment"># 默认模块和系统之间通信的计算机语言，默认为C语言。</span></span><br><span class="line"><span class="string">gather_subset</span>     <span class="string">=</span> <span class="type">!all</span>           <span class="comment"># 控制facts的收集种类，这样既拿到了我们需要的fact变量又提高了ansible的执行效率。这里指的是只收集min子集信息。</span></span><br><span class="line"><span class="string">host_key_checking</span> <span class="string">=</span> <span class="literal">False</span>          <span class="comment"># 首次连接是否检查主机密钥，默认为True。</span></span><br><span class="line"><span class="string">callback_whitelist</span> <span class="string">=</span> <span class="string">timer,</span> <span class="string">profile_tasks</span>  <span class="comment"># timer可以计算整个 playbook 的运行时间,插件profile_tasks可以看到task执行时间。</span></span><br><span class="line"><span class="string">stdout_callback</span> <span class="string">=</span> <span class="string">skippy</span></span><br><span class="line"><span class="string">module_name</span> <span class="string">=</span> <span class="string">shell</span>                <span class="comment"># 默认执行的模块</span></span><br><span class="line"><span class="string">ansible_managed</span> <span class="string">=</span> <span class="attr">Ansible managed:</span> <span class="string">&#123;file&#125;</span> <span class="string">on</span> <span class="string">&#123;host&#125;</span>  <span class="comment"># 定义一个Jinja2变量，可以插入到Ansible配置模板系统生成的文件中。</span></span><br><span class="line"><span class="string">system_warnings</span> <span class="string">=</span> <span class="literal">True</span>             <span class="comment"># 允许禁用系统运行ansible相关的潜在问题警告</span></span><br><span class="line"><span class="string">deprecation_warnings</span> <span class="string">=</span> <span class="literal">True</span>        <span class="comment"># 允许在ansible-playbook输出结果中禁用“不建议使用”警告</span></span><br><span class="line"><span class="string">command_warnings</span> <span class="string">=</span> <span class="literal">True</span>            <span class="comment"># 当shell和命令行模块被默认模块简化的时,Ansible将默认发出警告</span></span><br><span class="line"><span class="string">nocows</span> <span class="string">=</span> <span class="number">1</span>                         <span class="comment"># 默认ansible可以调用一些cowsay的特性   开启/禁用：0/1</span></span><br><span class="line"><span class="string">squash_actions</span> <span class="string">=</span> <span class="string">apk,apt,dnf,package,pacman,pkgng,yum,zypper,pip</span></span><br><span class="line"><span class="string">log_path</span> <span class="string">=</span> <span class="string">/dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="string">[privilege_escalation]</span></span><br><span class="line"><span class="string">become</span>          <span class="string">=</span> <span class="literal">True</span>             <span class="comment"># 是否sudo</span></span><br><span class="line"><span class="string">become_method</span>   <span class="string">=</span> <span class="string">sudo</span>             <span class="comment"># sudo方式</span></span><br><span class="line"><span class="string">become_ask_pass</span> <span class="string">=</span> <span class="literal">False</span>            <span class="comment"># sudo后是否验证密码</span></span><br><span class="line"><span class="string">become_user</span>     <span class="string">=</span> <span class="string">root</span>             <span class="comment"># sudo后变为root用户</span></span><br><span class="line"></span><br><span class="line"><span class="string">[paramiko_connection]</span></span><br><span class="line"><span class="string">record_host_keys=False</span>             <span class="comment"># 不记录新主机的key以提升效率</span></span><br><span class="line"></span><br><span class="line"><span class="string">[ssh_connection]</span>                   <span class="comment"># 调整SSH的通信连接</span></span><br><span class="line"><span class="string">scp_if_ssh</span> <span class="string">=</span> <span class="literal">True</span>                  <span class="comment"># 若连接类型是ssh，使ansible使用scp</span></span><br><span class="line"><span class="string">ssh_args</span> <span class="string">=</span> <span class="string">-o</span> <span class="string">ControlMaster=auto</span> <span class="string">-o</span> <span class="string">ControlPersist=600s</span> <span class="string">-o</span> <span class="string">ForwardAgent=yes</span>     <span class="comment"># 可以提高ControlPersist值来提高性能</span></span><br><span class="line"><span class="string">control_path=%(directory)s/ansible-ssh-%%h-%%p-%%r</span></span><br><span class="line"><span class="string">pipelining</span> <span class="string">=</span> <span class="literal">True</span>                  <span class="comment"># 管道加速，需配合requiretty使用方可生效</span></span><br></pre></td></tr></table></figure>
<h3 id="anbile配置文件的优先级"><a href="#anbile配置文件的优先级" class="headerlink" title="anbile配置文件的优先级"></a>anbile配置文件的优先级</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ansible 按照如下位置和顺序来查找 ansible.cfg 文件（1.5版本以后）：</span><br><span class="line">1、ANSIBLE_CONFIG 环境变量所指定的文件。</span><br><span class="line">2、./ansible.cfg （当前目录下的 ansible.cfg）。</span><br><span class="line">3、~/.ansible.cfg（主目录下的 .ansible.cfg）。</span><br><span class="line">4、/etc/ansible/ansible.cfg。</span><br></pre></td></tr></table></figure>
<h2 id="三、Ansible-Inventory"><a href="#三、Ansible-Inventory" class="headerlink" title="三、Ansible Inventory"></a>三、Ansible Inventory</h2><p>Inventory 是 Ansible 要管理对象的清单。在清单中，可以配置分组、主机信息等。</p>
<p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim /etc/ansible/hosts (默认路径)</span><br><span class="line">[test1]    # 组名</span><br><span class="line">10.15.0.163 ansible_ssh_user=&quot;zhuqifei&quot; ansible_ssh_port=2288 ansible_ssh_private_key_file=&quot;/home/zhuqifei/.id_rsa_ops&quot;</span><br><span class="line"></span><br><span class="line">[test2]    # 组名</span><br><span class="line">10.15.3.36 ansible_ssh_user=&quot;zhuqifei &quot; ansible_ssh_port=2288 ansible_ssh_private_key_file=&quot;/home/zhuqifei/.id_rsa_ops&quot;</span><br><span class="line"></span><br><span class="line">也可以自定义 Inventory 文件，然后通过 -i 的参数指定。</span><br></pre></td></tr></table></figure></p>
<p>Inventory 内置参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ansible_ssh_host</td>
<td style="text-align:center">定义主机的ssh地址</td>
</tr>
<tr>
<td style="text-align:center">ansible_ssh_port</td>
<td style="text-align:center">定义主机的ssh端口</td>
</tr>
<tr>
<td style="text-align:center">ansible_ssh_user</td>
<td style="text-align:center">定义主机的ssh认证用户</td>
</tr>
<tr>
<td style="text-align:center">ansible_ssh_pass</td>
<td style="text-align:center">定义主机的ssh认证密码</td>
</tr>
<tr>
<td style="text-align:center">ansible_sudo</td>
<td style="text-align:center">定义主机的sudo用户</td>
</tr>
<tr>
<td style="text-align:center">ansible_sudo_pass</td>
<td style="text-align:center">定义主机的sudo密码</td>
</tr>
<tr>
<td style="text-align:center">ansible_sudo_exe</td>
<td style="text-align:center">定义主机的sudo路径</td>
</tr>
<tr>
<td style="text-align:center">ansible_connection</td>
<td style="text-align:center">定义主机连接方式；与主机的连接类型.比如：local，ssh或者paramiko；Ansible 1.2以前默认使用paramiko。1.2以后的版本默认使用‘smart’，‘smart’方式会根据是否支持ControlPersist，来判断ssh方式是否可行</td>
</tr>
<tr>
<td style="text-align:center">ansible_ssh_private_key_file</td>
<td style="text-align:center">定义主机私钥文件</td>
</tr>
<tr>
<td style="text-align:center">ansible_shell_type</td>
<td style="text-align:center">定义主机shell类型</td>
</tr>
<tr>
<td style="text-align:center">ansible_python_interpreter</td>
<td style="text-align:center">定义主机python解释器路径</td>
</tr>
</tbody>
</table>
<h2 id="四、Ansible-使用"><a href="#四、Ansible-使用" class="headerlink" title="四、Ansible 使用"></a>四、Ansible 使用</h2><h3 id="介绍-ansible-命令行功能"><a href="#介绍-ansible-命令行功能" class="headerlink" title="介绍 ansible 命令行功能"></a>介绍 ansible 命令行功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(常用)</span><br><span class="line">ansible               # 这是 ansible 的主程序。</span><br><span class="line">ansible-playbook      # ansible剧本，使用yaml语法调用不同的功能模块。</span><br><span class="line">ansible-doc           # 这是 ansible 的帮助文档，显示模块的帮助信息。</span><br><span class="line">ansible-vault         # 文件加密工具。</span><br><span class="line">(不常用)</span><br><span class="line">ansible-console       # 基于console与用户进行交互  。   </span><br><span class="line">ansible-config</span><br><span class="line">ansible-connection</span><br><span class="line">ansible-galaxy        # 从网站共享和下载 Ansible 角色。</span><br><span class="line">ansible-inventory     # 展示链接的主机信息。</span><br><span class="line">ansible-pull          # 推送命令至远程。</span><br></pre></td></tr></table></figure>
<ul>
<li>ansible </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt; [-m module_name] [-a args]</span><br><span class="line"></span><br><span class="line">--version：显示版本</span><br><span class="line">-m  module：指定模块，才安装好ansible软件默认的模块是command</span><br><span class="line">-a ：模块参数</span><br><span class="line">-v ：显示简要的执行过程，-vv显示较为详细的过程，-vvv显示更为详细的执行过程</span><br><span class="line">--list-hostss：显示主机列表，可以简写 --list</span><br><span class="line">-k,--ask-pass：指定输入ssh连接密码，默认ansible是基于ssh key验证的（k是小写的）</span><br><span class="line">-K，--ask-become-pass提示输入sudo时的口令（k是大写的）</span><br><span class="line">-u：是指定远程以那个用户执行</span><br><span class="line">-s：表示使用sudo运行后面的操作</span><br><span class="line">-C，--check 检查，并不执行,这个参数主要用于检查playbook是否写的正确。</span><br><span class="line">-T，--timeout指定执行命令的超时时间，默认是10S。</span><br><span class="line">-u，指定以那个用户远程执行命令，指定的用户是远端服务器上存在的。并非本地管理端的用户。</span><br><span class="line">-b，--become代替旧版的sudo切换。</span><br><span class="line">--become-user-USERNAME 指定sudo的runas用户，默认是root</span><br></pre></td></tr></table></figure>
<ul>
<li>ansible-doc</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-doc [options] [module...]</span><br><span class="line"></span><br><span class="line">-a：显示所有模块的文档。</span><br><span class="line">-l，--list：列出全部可以模块。</span><br><span class="line">-s，--snippet：显示指定模块的playbook片段。</span><br></pre></td></tr></table></figure>
<h2 id="五、Ansible-常用模块与幂等性"><a href="#五、Ansible-常用模块与幂等性" class="headerlink" title="五、Ansible 常用模块与幂等性"></a>五、Ansible 常用模块与幂等性</h2><h3 id="常用的几个module模块"><a href="#常用的几个module模块" class="headerlink" title="常用的几个module模块"></a>常用的几个module模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调试和测试类的module</span><br><span class="line">ping - ping一下你的远程主机，如果可以通过ansible成功连接，那么返回pong</span><br><span class="line">debug - 用于调试的module，只是简单打印一些消息，有点像linux的echo命令。</span><br><span class="line">setup - 用来获取主机硬件信息及其他信息。</span><br><span class="line"></span><br><span class="line">文件类的module</span><br><span class="line">copy - 从本地拷贝文件到远程节点</span><br><span class="line">template - 从本地拷贝文件到远程节点，并进行变量的替换</span><br><span class="line">file - 设置文件的属性</span><br><span class="line"></span><br><span class="line">linux上常用的操作</span><br><span class="line">user - 管理用户账户</span><br><span class="line">yum - red hat系linux上的包管理</span><br><span class="line">service - 管理服务</span><br><span class="line">firewalld - 管理防火墙中的服务和端口</span><br><span class="line"></span><br><span class="line">执行Shell命令</span><br><span class="line">shell - 在节点上执行shell命令，支持$HOME和”&lt;”, “&gt;”, “|”, “;” and “&amp;”</span><br><span class="line">command - 在远程节点上面执行命令，不支持$HOME和”&lt;”, “&gt;”, “|”, “;” and “&amp;”</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ping</p>
<p>这个 Module 的作用是测试机器的连通性。我们可以通过调用这个 Module,可以判断远程客户端主机是否在线。</p>
<p>相关例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 连接成功后会显示SUCCESS并返回 'pong'。</span><br><span class="line">$ ansible -i hosts test1 -m ping  </span><br><span class="line">10.15.0.163 | SUCCESS =&gt; &#123;</span><br><span class="line">    "ansible_facts": &#123;</span><br><span class="line">        "discovered_interpreter_python": "/usr/bin/python"</span><br><span class="line">    &#125;,</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 连接失败后会显示 UNREACHABLE 并在 msg 中返回错误信息。</span><br><span class="line">$ ansible -i hosts test1 -m ping</span><br><span class="line">10.15.0.163 | UNREACHABLE! =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "msg": "Data could not be sent to remote host \"10.15.0.163\". Make sure this host can be reached over ssh: ssh: connect to host 10.15.0.163 port 22: Connection refused\r\n",</span><br><span class="line">    "unreachable": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setup<br>用来获取主机硬件信息及其他信息。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">10.15.0.163 | SUCCESS =&gt; &#123;</span><br><span class="line">    "ansible_facts": &#123;</span><br><span class="line">        "ansible_all_ipv4_addresses": [</span><br><span class="line">            <span class="string">"10.15.0.163"</span></span><br><span class="line">        ],</span><br><span class="line">        "ansible_all_ipv6_addresses": [],</span><br><span class="line">        "ansible_apparmor": &#123;</span><br><span class="line">            "status": "disabled"</span><br><span class="line">        &#125;,</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">        "ansible_swapfree_mb": 0,</span><br><span class="line">        "ansible_swaptotal_mb": 0,</span><br><span class="line">        "ansible_system": "Linux",</span><br><span class="line">        "ansible_system_capabilities": [],</span><br><span class="line">        "ansible_system_capabilities_enforced": "False",</span><br><span class="line">        "ansible_system_vendor": "OpenStack Foundation",</span><br><span class="line">        "ansible_uptime_seconds": 466,</span><br><span class="line">        "ansible_user_dir": "/root",</span><br><span class="line">        "ansible_user_gecos": "root",</span><br><span class="line">        "ansible_user_gid": 0,</span><br><span class="line">        "ansible_user_id": "root",</span><br><span class="line">        "ansible_user_shell": "/bin/bash",</span><br><span class="line">        "ansible_user_uid": 0,</span><br><span class="line">        "ansible_userspace_architecture": "x86_64",</span><br><span class="line">        "ansible_userspace_bits": "64",</span><br><span class="line">        "ansible_virtualization_role": "guest",</span><br><span class="line">        "ansible_virtualization_type": "openstack",</span><br><span class="line">        "discovered_interpreter_python": "/usr/bin/python",</span><br><span class="line">        "gather_subset": [</span><br><span class="line">            <span class="string">"all"</span></span><br><span class="line">        ],</span><br><span class="line">        "module_setup": true</span><br><span class="line">    &#125;,</span><br><span class="line">    "changed": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>copy<br>从当前的机器上copy静态文件到远程节点上，并且设置合理的文件权限。注意，copy module拷贝文件的时候，会先比较下文件的checksum，如果相同则不会拷贝，返回状态OK；如果不同才会拷贝，返回状态为changed。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim hello_zqf</span><br><span class="line">hello zhuqifei !!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ansible test1 -m copy -a &quot;src=hello_zqf dest=/opt/hello_zqf_copy mode=0644&quot;</span><br><span class="line">10.15.3.36 | CHANGED =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;checksum&quot;: &quot;8f757bf9cba9a7ec1d89f640ad045f7324b7fwea7&quot;,</span><br><span class="line">    &quot;dest&quot;: &quot;/opt/hello_zqf_copy&quot;,</span><br><span class="line">    &quot;gid&quot;: 0,</span><br><span class="line">    &quot;group&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;md5sum&quot;: &quot;8854f4d091437b07b96b47f70d62d5ca&quot;,</span><br><span class="line">    &quot;mode&quot;: &quot;0644&quot;,</span><br><span class="line">    &quot;owner&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;size&quot;: 28,</span><br><span class="line">    &quot;src&quot;: &quot;/home/zhuqifei/.ansible/tmp/ansible-tmp-1602501032.88-19490-228871563106293/source&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;file&quot;,</span><br><span class="line">    &quot;uid&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://cdn.zqifei.com/20201012160249875796674.png" alt="20201012160249875796674.png"></p>
<ul>
<li>template<br>如果你需要拷贝一个静态的文件，那么用copy module就够用了。但是如果你需要拷贝一个文件，并且需要修改部分内容，那么就需要用到template module啦。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim hello_zqf.j2</span><br><span class="line">hello &#123;&#123; dynamic_word &#125;&#125; !!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ansible test1 -m template -a &quot;src=hello_zqf.j2 dest=/opt/hello_zqf_template mode=0644&quot; --extra-vars=&quot;dynamic_word=zhuqifei&quot;</span><br><span class="line">10.15.3.36 | CHANGED =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;checksum&quot;: &quot;c01f87bababc49bdd9e617dcd391c4209303b8ed&quot;,</span><br><span class="line">    &quot;dest&quot;: &quot;/opt/hello_zqf&quot;,</span><br><span class="line">    &quot;gid&quot;: 0,</span><br><span class="line">    &quot;group&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;md5sum&quot;: &quot;e55afdc802d9912266811ed17b3d5088&quot;,</span><br><span class="line">    &quot;mode&quot;: &quot;0644&quot;,</span><br><span class="line">    &quot;owner&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;size&quot;: 18,</span><br><span class="line">    &quot;src&quot;: &quot;/home/zhuqifei/.ansible/tmp/ansible-tmp-1602500948.89-17460-59368747945805/source&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;file&quot;,</span><br><span class="line">    &quot;uid&quot;: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 可以看到源文件中 &#123;&#123; dynamic_word &#125;&#125; 变量被替换为指定的变量值了。</span><br><span class="line">$ cat /opt/hello_zqf_template</span><br><span class="line">hello zhuqifei !!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://cdn.zqifei.com/20201012160250058265115.png" alt="20201012160250058265115.png"></p>
<ul>
<li>yum<br>yum module是用来管理red hat系的Linux上的安装包的，包括RHEL，CentOS，和fedora 21一下的版本。fedora从版本22开始就使用dnf，推荐使用dnf module来进行安装包的操作。<br>安装最新版本的包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ansible -i hosts all -m yum -a “name=nginx state=latest” --become-user root --become</span><br><span class="line">10.15.3.36 | CHANGED =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;changes&quot;: &#123;</span><br><span class="line">        &quot;installed&quot;: [</span><br><span class="line">            &quot;nginx&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;updated&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;,</span><br><span class="line">    &quot;obsoletes&quot;: &#123;</span><br><span class="line">        &quot;iwl7265-firmware&quot;: &#123;</span><br><span class="line">            &quot;dist&quot;: &quot;noarch&quot;,</span><br><span class="line">            &quot;repo&quot;: &quot;@base&quot;,</span><br><span class="line">            &quot;version&quot;: &quot;22.0.7.0-72.el7&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rc&quot;: 0,</span><br><span class="line">    &quot;results&quot;: [</span><br><span class="line">        &quot;Loaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\nResolving Dependencies\n--&gt; Running transaction check\n---&gt; Package nginx.x86_64</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://cdn.zqifei.com/20201012160249652378188.png" alt="20201012160249652378188.png"></p>
<ul>
<li><p>command<br>在远程主机执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ansible -i hosts all -m command -a &quot;hostname&quot;</span><br><span class="line">10.15.3.36 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">zqf-ansible-test-0001</span><br><span class="line">10.15.0.163 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">zqf-ansible-test-0002</span><br></pre></td></tr></table></figure>
</li>
<li><p>service<br>管理远程节点上的服务，什么是服务呢，比如httpd、sshd、nfs、crond等，等同于Linux下的service命令。<br><img src="http://cdn.zqifei.com/20201012160250215229437.png" alt="20201012160250215229437.png"></p>
</li>
<li><p>更多模块<br><a href="https://github.com/ansible/ansible/tree/devel/lib/ansible/modules" target="_blank" rel="noopener">https://github.com/ansible/ansible/tree/devel/lib/ansible/modules</a></p>
</li>
</ul>
<h3 id="执行过程及原理说明"><a href="#执行过程及原理说明" class="headerlink" title="执行过程及原理说明"></a>执行过程及原理说明</h3><p>1、加载配置文件，默认是/etc/ansible/ansible.cfg</p>
<p>2、加载对应模块</p>
<p>3、生产临时py文件，并传输到目标机器的~/.ansible/tmp目录下</p>
<p>4、给py文件加上+x权限，执行并返回结果</p>
<p>5、删除py文件并sleep 0 退出</p>
<h3 id="什么是幂等性？"><a href="#什么是幂等性？" class="headerlink" title="什么是幂等性？"></a>什么是幂等性？</h3><p>幂等性是数学和计算机科学上一个常见的概念，多次执行产生的结果不会发生改变，这样的特性就被成为幂等性。</p>
<p>Ansible 包含众多的模块，大部分模块都能够保证操作的幂等性，既相关操作的多次执行能够达到相同结果这一特性，但是也有不满足幂等原则的，比如shell模块和row模块。</p>
<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p><a href="https://getansible.com/" target="_blank" rel="noopener">Ansible入门</a><br><a href="https://www.eflycloud.com/blog/blogDetail?id=661" target="_blank" rel="noopener">Ansible原理与安装部署</a></p>
]]></content>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>MegaCli常用命令</title>
    <url>/MegaCli%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<h2 id="MegaCli工具介绍"><a href="#MegaCli工具介绍" class="headerlink" title="MegaCli工具介绍"></a>MegaCli工具介绍</h2><ul>
<li><p>MegaCli 是一款管理维护硬件 RAID 软件，可以通过它来了解当前 raid 卡的所有信息，包括 raid 卡的型号，raid 的阵列类型，raid 上各磁盘状态等等。</p>
</li>
<li><p>通常，我们对硬盘当前的状态不太好确定，一般通过机房人员巡检来完成，有没有通过软件的方式来检查确定这个问题呢。MegaCli就可以做到，一般通过MegaCli 的 Media Error Count: 0 Other Error Count: 0 这两个数值来确定阵列中磁盘是否有问题；Media Error Count 表示磁盘有可能错误，可能是磁盘有坏道，这个值不为 0 值得注意，数值越大，危险系数越高。Other Error Count 表示磁盘可能存在松动，可能需要再重新插入。MegaCli 可以对阵列中所有的磁盘进行检测，我们可以通过脚本的方式来检测相关参数，从而通知管理人员。</p>
</li>
</ul>
<h2 id="下载MegaCli管理工具"><a href="#下载MegaCli管理工具" class="headerlink" title="下载MegaCli管理工具"></a>下载MegaCli管理工具</h2><p>MegaCli工具可以从各个服务器的官方下载或者LSI网站上进行下载，一般来说，工具是通用的。</p>
<p>下载地址： <strong><a href="ftp://download2.boulder.ibm.com/ecc/sar/CMA/XSA/ibm_utl_sraidmr_megacli-8.00.48_linux_32-64.zip" target="_blank" rel="noopener">ftp://download2.boulder.ibm.com/ecc/sar/CMA/XSA/ibm_utl_sraidmr_megacli-8.00.48_linux_32-64.zip</a></strong></p>
<h2 id="安装MegaCLi"><a href="#安装MegaCLi" class="headerlink" title="安装MegaCLi"></a>安装MegaCLi</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ unzip ibm_utl_sraidmr_megacli-8.00.48_linux_32-64.zip</span><br><span class="line">$ <span class="built_in">cd</span> linux</span><br><span class="line">$ rpm -ivh Lib_Utils-1.00-09.noarch.rpm  MegaCli-8.00.48-1.i386.rpm</span><br><span class="line">$ ln -sf /opt/MegaRAID/MegaCli/MegaCli64 /usr/bin/megacli</span><br></pre></td></tr></table></figure>
<h2 id="使用命令和参数"><a href="#使用命令和参数" class="headerlink" title="使用命令和参数"></a>使用命令和参数</h2><p>1.常用命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDInfo -Lall -aALL  [查raid级别]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpAllInfo -aAll    [查raid卡信息]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDList -aAll 	   [查看硬盘信息]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpBbuCmd -aAll     [查看电池信息]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -FwTermLog -Dsply -aAll  [查看raid卡日志]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -adpCount            [显示适配器个数]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpGetTime -aAll    [显示适配器时间]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpAllInfo -aAll    [显示所有适配器信息]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDInfo -LAll -aALl  [显示所有逻辑磁盘组信息]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDList -aALl        [显示所有的物理信息]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpBbuCmd -GetBbuStatus -aAll | grep <span class="string">'Charger Status'</span>  [查看充电状态]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpBbuCmd -GetBbuStatus -aAll  [显示BBU状态信息]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpBbuCmd -GetBbuCapacityInfo -aALl  [显示BBU容量信息]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpBbuCmd -GetBbuDesignInfo -aAll    [显示BBU设计参数]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -AdpBbuCmd -GetBbuProperties -aAll    [显示当前BBU属性]</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -cfgdsply -aAll [显示raid卡型号，raid设置，disk相关信息]</span><br></pre></td></tr></table></figure></p>
<p>2.磁带状态的变化，从拔盘，到插盘的过程中<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Device |Normal|Damage|Rebuild|Normal</span><br><span class="line">Virtual Drive |Optimal|Degraded|Degraded|Optimal</span><br><span class="line">Physical Drive |Online|Failed –&gt; Unconfigured|Rebuild|Online</span><br></pre></td></tr></table></figure></p>
<p>3.查看磁盘缓存策略<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDGetProp -Cache -L0 -a0</span><br><span class="line">or</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LdGetProp -Cache -L1 -a0</span><br><span class="line">or</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDGetProp -Cache -LALL -a0</span><br><span class="line">or</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDGetProp -Cache -LALL -aALL</span><br><span class="line">or</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDGetProp -DskCache -LALL -aALL</span><br></pre></td></tr></table></figure></p>
<p>4.设置磁盘缓存策略<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">缓存策略解释：</span><br><span class="line">WT (Write through)</span><br><span class="line">WB (Write back)</span><br><span class="line">NORA (No <span class="built_in">read</span> ahead)</span><br><span class="line">RA (Read ahead)</span><br><span class="line">ADRA (Adaptive <span class="built_in">read</span> ahead)</span><br><span class="line">Cached</span><br><span class="line">Direct</span><br><span class="line">    </span><br><span class="line">例如：</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDSetProp WT|WB|NORA|RA|ADRA -L0 -a0</span><br><span class="line">or</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDSetProp -Cached|-Direct -L0 -a0</span><br><span class="line">or</span><br><span class="line"><span class="built_in">enable</span> / <span class="built_in">disable</span> disk cache</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDSetProp -EnDskCache|-DisDskCache -L0 -a0</span><br></pre></td></tr></table></figure></p>
<p>5.创建一个 raid5 阵列，由物理盘 2，3，4构成，该阵列的热备盘是物理盘 5。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct -Hsp[1:5] -a0</span><br></pre></td></tr></table></figure></p>
<p>6.创建阵列，不指定热备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct -a0</span><br></pre></td></tr></table></figure></p>
<p>7.删除阵列<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -CfgLdDel -L1 -a0</span><br></pre></td></tr></table></figure></p>
<p>8.在线添加磁盘<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDRecon -Start -r5 -Add -PhysDrv[1:4] -L1 -a0</span><br></pre></td></tr></table></figure></p>
<p>9.阵列创建完后，会有一个初始化同步块的过程，可以看看其进度<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDInit -ShowProg -LALL -aALL</span><br><span class="line">或者以动态可视化文字界面显示</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDInit -PropDsply -LALL -aALL</span><br></pre></td></tr></table></figure></p>
<p>10.查看阵列后台初始化进度<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDBI -ShowProg -LALL -aALL</span><br><span class="line">或者以动态可视化文字界面显示</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -LDBI -ProgDsply -LALL -aALL</span><br></pre></td></tr></table></figure></p>
<p>11.指定第5块盘<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDHSP -Set [-EnclAffinity] [-nonRevertible] -PhysDrv[1:5] -a0</span><br></pre></td></tr></table></figure></p>
<p>12.指定为某个阵列的专用热备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDHSP -Set [-Dedicated [-Array1]] [-EnclAffinity] [-nonRevertible] -PhysDrv[1:5] -a0</span><br></pre></td></tr></table></figure></p>
<p>13.删除全局热备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDHSP -Rmv -PhysDrv[1:5] -a0</span><br></pre></td></tr></table></figure></p>
<p>14.将某块物理盘下线/上线<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDOffline -PhysDrv [1:4] -a0</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDOnline -PhysDrv [1:4] -a0</span><br></pre></td></tr></table></figure></p>
<p>15.将某块物理盘重建进度<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDRbld -ShowProg -PhysDrv [1:5] -a0</span><br><span class="line">$ /opt/MegaRAID/MegaCli/MegaCli64  -PDRbld -ProgDsply -PhysDrv [1:5] -a0</span><br></pre></td></tr></table></figure></p>
<p>转自：<a href="http://blog.chinaunix.net/uid-25135004-id-3139293.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-25135004-id-3139293.html</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>硬盘SMART属性详解</title>
    <url>/%E7%A1%AC%E7%9B%98SMART%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h1 id="一、SMART概述"><a href="#一、SMART概述" class="headerlink" title="一、SMART概述"></a>一、SMART概述</h1><pre><code> S.M.A.R.T（Self-Monitoring Analysis And Reporting Technology），即“自我监测、分析及报告技术”，是一种自动监控硬盘驱动器完好状况和报告潜在问题的技术标准。支持S.M.A.R.T技术的硬盘可以通过硬盘上的监测指令和主机上的监测软件对磁头、盘片、马达、电路的运行情况、历史记录及预设的安全值进行分析、比较。当出现安全值范围以外的情况时，就会自动向用户发出警告。

 最早期的硬盘监控技术起源于1992年，IBM在AS/400计算机的IBM 0662 SCSI 2代硬盘驱动器中使用了Predictive Failure Analysis（故障预警分析技术）的监控技术，它通过在固件中测量几个重要的硬盘安全参数和评估他们的情况，然后由监控软件得出两种结果：“硬盘安全”或“不久后会发生故障”。

 不久，当时的微机制造商康柏和硬盘制造商希捷、昆腾和康纳共同提出了名为IntelliSafe的类似技术。通过该技术，硬盘可以测量自身的健康指标并将参量值传送给操作系统和用户的监控软件中，每个硬盘生产商有权决定哪些指标需要被监控以及设定它们的安全阈值。

 1995年，康柏公司将该技术方案提交到Small Form Factor(SFF)委员会进行标准化，该方案得到IBM、希捷、昆腾、康纳和西部数据的支持，1996年6月进行了1.3版的修正，正式更名为S.M.A.R.T（Self-Monitoring Analysis And Reporting  Technology），即“自我检测分析与报告技术”。

 SMART的目的是监控硬盘的可靠性、预测磁盘故障和执行各种类型的磁盘自检。如今大部分的ATA/SATA、SCSI/SAS和固态硬盘都搭载内置的SMART系统。作为行业规范，SMART规定了硬盘制造厂商应该遵循的标准，满足SMART标准的条件主要包括： 

1)   在设备制造期间完成SMART需要的各项参数、属性的设定；

2)   允许用户自由开启和关闭SMART功能； 

3)   在特定系统平台下，能够正常使用SMART；通过BIOS检测，能够识别设备是否支持SMART并可显示相关信息，而且能辨别有效和失效的SMART信息； 

4)   在用户使用过程中，能提供SMART的各项有效信息，确定设备的工作状态，并能发出相应的修正指令或警告。在硬盘及操作系统都支持SMART技术并且开启的情况下，若硬盘状态不良，SMART技术能够在屏幕上显示英文警告信息。

 SMART不断从硬盘上的各个传感器收集信息，并把信息保存在硬盘的系统保留区(service area)内；这个区域一般位于硬盘0物理面的最前面几十个物理磁道，由厂商写入相关的内部管理程序。这里除了SMART信息表外还包括低级格式化程序、加密解密程序、自监控程序、自动修复程序等。用户可使用的监测软件，执行“SMART Return Status”命令（命令代码：B0h）对SMART信息进行读取，但此命令且不允许最终用户对信息进行修改。
</code></pre><h1 id="二、SMART的值和ID"><a href="#二、SMART的值和ID" class="headerlink" title="二、SMART的值和ID"></a>二、SMART的值和ID</h1><pre><code>SMART ID代码是用两位十六进制数表示的硬盘各项检测参数。目前，各硬盘制造商的绝大部分ID代码所代表的参数含义是一致的，但不同制造商的描述有微小差别，或者根据检测项目的多少增减ID代码。

SATA和SAS的SMART信息也是大同小异的。

SMART反映了各项参数的具体情况，主要包括临界值（Threshold）、当前值（Normalized value）、最差值（Worst）、数据值（Data或Raw value）。
</code></pre><h2 id="2-1-临界值Threshold"><a href="#2-1-临界值Threshold" class="headerlink" title="2.1 临界值Threshold"></a>2.1 临界值Threshold</h2><pre><code>临界值是硬盘厂商指定的表示某一项目可靠性的门限值，它通过特定公式计算而得。如果某个参数的当前值接近了临界值，就意味着硬盘将变得不可靠，可能导致数据丢失或者硬盘故障。由于临界值是硬盘厂商根据自己产品特性而确定的，因此用厂商提供的专用检测软件往往会跟Windows下检测软件的检测结果有较大出入。
</code></pre><h2 id="2-2-当前值（Normalized-value）"><a href="#2-2-当前值（Normalized-value）" class="headerlink" title="2.2 当前值（Normalized value）"></a>2.2 当前值（Normalized value）</h2><pre><code>当前值是各ID项在硬盘运行时根据实测数据通过公式计算的结果，计算公式由硬盘厂家自定。 硬盘出厂时各ID项目都有一个预设的最大正常值，即出厂值，这个预设的依据及计算方法为硬盘厂家保密，不同型号的硬盘都不同，最大正常值通常为100或200或253，新硬盘刚开始使用时显示的当前值可以认为是预设的最大正常值（有些ID项如温度等除外）。随着使用损耗或出现错误，当前值会根据实测数据而不断刷新并逐渐减小。

因此，当前值接近临界值就意味着硬盘寿命的减少，发生故障的可能性增大，所以当前值也是判定硬盘健康状态或推测寿命的依据之一。
</code></pre><h2 id="2-3-最差值（Worst）"><a href="#2-3-最差值（Worst）" class="headerlink" title="2.3 最差值（Worst）"></a>2.3 最差值（Worst）</h2><pre><code>最差值是对硬盘运行中某项数据变劣的峰值统计，该数值也会不断刷新。通常，最差值与当前值是相等的，如果最差值出现较大的波动（小于当前值），表明硬盘曾出现错误或曾经历过恶劣的工作环境（如温度）。
</code></pre><h2 id="2-4-数据值（Data或Raw-value）"><a href="#2-4-数据值（Data或Raw-value）" class="headerlink" title="2.4 数据值（Data或Raw value）"></a>2.4 数据值（Data或Raw value）</h2><pre><code>数据值是硬盘运行时各ID项参数的实测值，数据值代表的意义随参数而定，大致可以分为三类：

1）数据值是直接累计的，如Start/Stop Count（启动/停止计数）的数据是50，即表示该硬盘从出厂到现在累计启停了50次； 

2）有些参数的数据是即时数，如Temperature（温度）的数据值是44，表示硬盘的当前温度是44℃；

3）有些参数直接查看数据也能大致了解硬盘目前的工作状态；但是，也有很多数据值并不直接反映硬盘状态，必须经过硬盘内置的计算公式换算成当前值才能得出结果.
</code></pre><h2 id="2-5-TYPE"><a href="#2-5-TYPE" class="headerlink" title="2.5 TYPE"></a>2.5 TYPE</h2><pre><code>属性的类型（Pre-fail或Oldage）。Pre-fail类型的属性可被看成一个关键属性，表示参与磁盘的整体SMART健康评估是否通过（PASSED/FAILED）。如果任何Pre-fail类型的属性故障，那么可视为磁盘将要发生故障。另一方面，Oldage类型的属性可被看成一个非关键的属性（如正常的磁盘磨损），表示不会使磁盘本身发生故障。
</code></pre><h2 id="2-6-UPDATED"><a href="#2-6-UPDATED" class="headerlink" title="2.6 UPDATED"></a>2.6 UPDATED</h2><pre><code>表示属性的更新频率。Offline代表磁盘上执行离线测试的时间。
</code></pre><h2 id="2-7-WHEN-FAILED"><a href="#2-7-WHEN-FAILED" class="headerlink" title="2.7 WHEN_FAILED"></a>2.7 WHEN_FAILED</h2><pre><code>如果VALUE小于等于THRESH，会被设置成“FAILING_NOW”；如果WORST小于等于THRESH会被设置成“In_the_past”；如果都不是，会被设置成“-”。在“FAILING_NOW”情况下，需要尽快备份重要 文件，特别是属性是Pre-fail类型时。“In_the_past”代表属性已经故障了，但在运行测试的时候没问题。“-”代表这个属性从没故障过。
</code></pre><h1 id="三、SMART状态（Status）和参数详解"><a href="#三、SMART状态（Status）和参数详解" class="headerlink" title="三、SMART状态（Status）和参数详解"></a>三、SMART状态（Status）和参数详解</h1><h2 id="3-1-SATA-SMART日志示例"><a href="#3-1-SATA-SMART日志示例" class="headerlink" title="3.1 SATA SMART日志示例"></a>3.1 SATA SMART日志示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=== START OF READ SMART DATA SECTION ===</span><br><span class="line">SMART overall-health self-assessment test result: PASSED</span><br><span class="line"></span><br><span class="line">General SMART Values:</span><br><span class="line">Offline data collection status:  (0x82)	Offline data collection activity</span><br><span class="line">					was completed without error.</span><br><span class="line">					Auto Offline Data Collection: Enabled.</span><br><span class="line">Self-test execution status:      (   0)	The previous self-test routine completed</span><br><span class="line">					without error or no self-test has ever </span><br><span class="line">					been run.</span><br><span class="line">Total time to complete Offline </span><br><span class="line">data collection: 		(  113) seconds.</span><br><span class="line">Offline data collection</span><br><span class="line">capabilities: 			 (0x5b) SMART execute Offline immediate.</span><br><span class="line">					Auto Offline data collection on/off support.</span><br><span class="line">					Suspend Offline collection upon new</span><br><span class="line">					command.</span><br><span class="line">					Offline surface scan supported.</span><br><span class="line">					Self-test supported.</span><br><span class="line">					No Conveyance Self-test supported.</span><br><span class="line">					Selective Self-test supported.</span><br><span class="line">SMART capabilities:            (0x0003)	Saves SMART data before entering</span><br><span class="line">					power-saving mode.</span><br><span class="line">					Supports SMART auto save timer.</span><br><span class="line">Error logging capability:        (0x01)	Error logging supported.</span><br><span class="line">					General Purpose Logging supported.</span><br><span class="line">Short self-test routine </span><br><span class="line">recommended polling time: 	 (   2) minutes.</span><br><span class="line">Extended self-test routine</span><br><span class="line">recommended polling time: 	 ( 571) minutes.</span><br><span class="line">SCT capabilities: 	       (0x003d)	SCT Status supported.</span><br><span class="line">					SCT Error Recovery Control supported.</span><br><span class="line">					SCT Feature Control supported.</span><br><span class="line">					SCT Data Table supported.</span><br><span class="line"></span><br><span class="line">SMART Attributes Data Structure revision number: 16</span><br><span class="line">Vendor Specific SMART Attributes with Thresholds:</span><br><span class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</span><br><span class="line">  1 Raw_Read_Error_Rate     0x000b   093   093   016    Pre-fail  Always       -       1703946</span><br><span class="line">  2 Throughput_Performance  0x0005   137   137   054    Pre-fail  Offline      -       104</span><br><span class="line">  3 Spin_Up_Time            0x0007   100   100   024    Pre-fail  Always       -       0</span><br><span class="line">  4 Start_Stop_Count        0x0012   100   100   000    Old_age   Always       -       4</span><br><span class="line">  5 Reallocated_Sector_Ct   0x0033   087   087   005    Pre-fail  Always       -       3</span><br><span class="line">  7 Seek_Error_Rate         0x000b   100   100   067    Pre-fail  Always       -       0</span><br><span class="line">  8 Seek_Time_Performance   0x0005   128   128   020    Pre-fail  Offline      -       18</span><br><span class="line">  9 Power_On_Hours          0x0012   100   100   000    Old_age   Always       -       6318</span><br><span class="line"> 10 Spin_Retry_Count        0x0013   100   100   060    Pre-fail  Always       -       0</span><br><span class="line"> 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       4</span><br><span class="line">192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       343</span><br><span class="line">193 Load_Cycle_Count        0x0012   100   100   000    Old_age   Always       -       343</span><br><span class="line">194 Temperature_Celsius     0x0002   162   162   000    Old_age   Always       -       37 (Min/Max 23/42)</span><br><span class="line">196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       3</span><br><span class="line">197 Current_Pending_Sector  0x0022   087   087   000    Old_age   Always       -       4600</span><br><span class="line">198 Offline_Uncorrectable   0x0008   100   100   000    Old_age   Offline      -       282</span><br><span class="line">199 UDMA_CRC_Error_Count    0x000a   200   200   000    Old_age   Always       -       0</span><br></pre></td></tr></table></figure>
<h2 id="3-2-SATA-SMART的参数详解"><a href="#3-2-SATA-SMART的参数详解" class="headerlink" title="3.2 SATA SMART的参数详解"></a>3.2 SATA SMART的参数详解</h2><pre><code>属性描述(Attribute Description)即检测项目名称。可由厂商自定义增减，由于ATA标准不断更新，有时候同一品牌的不同型号产品也会有所不同。

有背景颜色的属性，都是需要重点对待的。
</code></pre><p><font color="#dd0000">01h(001) Raw Read Error Rate 底层数据读取错误率</font><br> </p>
<pre><code>数据为0或任意值，当前值应远大于与临界值。

底层数据读取错误率是磁头从磁盘表面读取数据时出现的错误，对某些硬盘来说，大于0的数据表明磁盘表面或者读写磁头发生问题，如介质损伤、磁头污染、磁头共振等等。不过对希捷硬盘来说，许多硬盘的这一项会有很大的数据量，这不代表有任何问题，主要是看当前值下降的程度。

在固态硬盘中，此项的数据值包含了可校正的错误与不可校正的RAISE错误（UECC＋URAISE）。
</code></pre><p><font color="#dd0000">02h(002) Throughput Performance 读写通量性能</font><br></p>
<pre><code>此参数表示硬盘的读写通量性能，数据值越大越好。当前值如果偏低或趋近临界值，表示硬盘存在严重的问题，但现在的硬盘通常显示数据值为0或根本不显示此项，一般在进行了人工脱机SMART测试后才会有数据量。
</code></pre><p>03h(003) Spin-Up Time 硬盘主轴起转时间</p>
<pre><code>主轴起旋时间就是主轴电机从启动至达到额定转速所用的时间，数据值直接显示时间，单位为毫秒或者秒，因此数据值越小越好。不过对于正常硬盘来说，这一项仅仅是一个参考值，硬盘每次的启动时间都不相同，某次启动的稍慢些也不表示就有问题。 

硬盘的主轴电机从启动至达到额定转速大致需要4秒～15秒左右，过长的启动时间说明电机驱动电路或者轴承机构有问题。一旦这一参数的数据值在某些型号的硬盘上总是为0，这就要看当前值和最差值来判断了。  

对于固态硬盘来说，所有的数据都是保存在半导体集成电路中，没有主轴电机，所以这项没有意义，数据固定为0，当前值固定为100。
</code></pre><p><font color="#dd0000">04h(004) Start/Stop Count 马达启停次数(又称加电次数)</font><br></p>
<pre><code>这一参数的数据是累计值，表示硬盘主轴电机启动/停止的次数，新硬盘通常只有几次，以后会逐渐增加。系统的某些功能如空闲时关闭硬盘等会使硬盘启动/停止的次数大为增加，在排除定时功能的影响下，过高的启动/停止次数（远大于通电次数0C）暗示硬盘电机及其驱动电路可能有问题。  

这个参数的当前值是依据某种公式计算的结果，例如对希捷某硬盘来说临界值为20，当前值是通过公式“100－（启停计数/1024）”计算得出的。若新硬盘的启停计数为0，当前值为100－(0/1024)＝100，随着启停次数的增加，该值不断下降，当启停次数达到81920次时，当前值为100－(81920/1024)＝20，已达到临界值，表示从启停次数来看，该硬盘已达设计寿命，当然这只是个寿命参考值，并不具有确定的指标性。  

这一项对于固态硬盘同样没有意义，数据固定为0，当前值固定为100。
</code></pre><p><font color="#dd0000">05h(005) Relocated Sector Count 重映射扇区数（Glist）</font><br></p>
<pre><code>数据应为0，当前值应远大于临界值。

这项参数的数据值直接表示已经被重映射扇区的数量，当前值则随着数据值的增加而持续下降。当发现此项的数据值不为零时，要密切注意其发展趋势，若能长期保持稳定，则硬盘还可以正常运行；若数值不断上升，说明不良扇区不断增加，硬盘已处于不稳定状态，应当考虑更换了。如果当前值接近或已到达临界值（此时的数据值并不一定很大，因为不同硬盘保留的备用扇区数并不相同），表示缺陷表已满或备用扇区已用尽，已经失去了重映射功能，再出现不良扇区就会显现出来并直接导致数据丢失。  

 这一项不仅是硬盘的寿命关键参数，而且重映射扇区的数量也直接影响硬盘的性能，例如某些硬盘会出现数据量很大，但当前值下降不明显的情况，这种硬盘尽管还可正常运行，但也不宜继续使用。因为备用扇区都是位于磁盘尾部（靠近盘片轴心处），大量的使用备用扇区会使寻道时间增加，硬盘性能明显下降。
</code></pre><p><font color="#dd0000">07h(007) Seek Error Rate 寻道错误率</font><br></p>
<pre><code>数据应为0或者远远大于0，当前值应远大于与临界值。  

这一项表示磁头寻道时的错误率，有众多因素可导致寻道错误率上升，如磁头组件的机械系统、伺服电路有局部问题，盘片表面介质不良，硬盘温度过高等。

如果这里接近阈值，就说明硬盘马上就要挂了。
</code></pre><p>08h(008) Seek Time Performance 寻道性能</p>
<pre><code>此项表示硬盘寻道操作的平均性能（寻道速度），通常与前一项（寻道错误率）相关联。当前值持续下降标志着磁头组件、寻道电机或伺服电路出现问题，但现在许多硬盘并不显示这一项。
</code></pre><p>09h(009) Power-On Hours硬盘加电时间</p>
<pre><code>此参数表示硬盘自出厂以来加电启动的统计时间，单位为小时。
</code></pre><p><font color="#dd0000">0Ah(010) Spin up Retry Count 马达起转重试次数(即硬盘启动重试次数)</font><br></p>
<pre><code>数据应为0，当前值应大于临界值。

主轴电机在一次加速至正常速度失败后尝试重新继续加速到正常运行速度的统计数；这个数值的增加说明电机驱动或者机械子系统出现问题，也可能是整机供电不足。
</code></pre><p><font color="#dd0000">0Bh(011) Calibration Retry Count 磁头校准重试次数</font><br></p>
<pre><code>数据应为0，当前值应远大于与临界值。

磁头在一次运行失败时尝试校准至正常状态的统计数，这个数值的增加表示点击驱动电路或者机械子系统出现问题。
</code></pre><p>0Ch(012) Power Cycle Count  通电周期计数</p>
<pre><code>通电周期计数的数据值表示了硬盘通电/断电的次数，即电源开关次数的累计，反映硬盘寿命的一个参考值。
</code></pre><p>0Dh(013) Soft Read Error Rate 软件读取错误率</p>
<pre><code>软件读取错误率也称为可校正的读取误码率，就是报告给操作系统的未经校正的读取错误。数据值越低越好，过高则可能暗示盘片磁介质有问题。
</code></pre><p>B4h(180) Unused Reserved Block Count Total未用的备用块计数（惠普） </p>
<pre><code>固态硬盘会保留一些容量来准备替换损坏的存储单元，所以可用的预留空间数是非常重要的。这个参数的当前值表示尚未使用的预留的存储单元数量。
</code></pre><p>B7h(183) SATA Downshift Error Count 串口降速错误计数</p>
<pre><code>这一项表示SATA接口速率错误下降的次数。通常硬盘与主板之间的兼容问题会导致SATA传输级别降级运行。
</code></pre><p>B8h(184) End to End Error Detection Count 端到端错误检测次数</p>
<pre><code>Intel第二代的34nm固态硬盘有点到点错误检测计数这一项。固态硬盘里有一个LBA（logical block addressing，逻辑块地址）记录，这一项显示了SSD内部逻辑块地址与真实物理地址间映射的出错次数。
</code></pre><p>BBh(187) Reported Uncorrectable Errors 无法校正的错误</p>
<pre><code>报告给OS的无法通过硬件ECC校正的错误，如果数值大于0，应该注意硬盘安全，甚至备份数据。
</code></pre><p>BCh(188) Command Timeout  通信超时</p>
<pre><code>由于无法连接至硬盘而终止操作的统计数，一般为0，如果远超过0，则可能电源供电问题或数据线接口氧化，也可能是硬盘出现更严重的问题。
</code></pre><p>BDh189) High Fly Writes 高飞写入</p>
<pre><code>这一项的数据值就统计了写入时磁头飞行高度出现偏差的次数。硬盘进行写入时对磁头高度进行监控以提供额外的保障;当磁头处于不正常高度进行写入时，写入操作会被终止，原有数据重写入或者将该扇区重映射到安全区域,该属性是统计值。
</code></pre><p>BEh(190) Airflow Temperature 气流温度</p>
<pre><code>这一项表示的是硬盘内部盘片表面的气流温度。在希捷公司的某些硬盘中，当前值=（100－当前温度），因此气流温度越高，当前值就越低，最差值则是当前值曾经到达过的最低点，临界值由制造商定义的最高允许温度来确定，而数据值不具实际意义。许多硬盘也没有这一项参数。
</code></pre><p>BFh(191) G-sense Error Rate 冲击错误率</p>
<pre><code>这一项的数值记录了硬盘受到机械冲击导致出错的频度。
</code></pre><p>C0h(192) Power-Off Retract Count断电返回计数 </p>
<pre><code>此参数表示不安全断电时候磁头返回的次数。但要注意这个参数对某些硬盘来说，仅记录意外断电时磁头的返回动作；而某些硬盘记录了所有（包括休眠、待机，但不包括关机时）的磁头返回动作；还有些硬盘这一项没有记录。

因此这一参数的数据值在某些硬盘上持续为0或稍大于0，但在另外的硬盘上则会大于通电周期计数（0C）或启停计数（04）的数据。在一些新型节能硬盘中，这一参数的数据量还与硬盘的节能设计相关，可能会远大于通电周期计数（0C）或启停计数（04）的数据，但又远小于磁头加载/卸载计数（C1）的数据量。

对于固态硬盘来说，虽然没有磁头的加载/卸载操作，但这一项的数据量仍然代表了不安全关机，即发生意外断电的次数。
</code></pre><p>C1h(193) Load Cycle Count 磁头加载/卸载次数</p>
<pre><code>这个参数的数据值就是磁头执行加载/卸载操作的累计次数。从原理上讲，这个加载/卸载次数应当与硬盘的启停次数相当，但对于笔记本内置硬盘以及台式机新型节能硬盘来说，这一项的数据量会很大。这是因为磁头臂组件设计有一个固定的返回力矩，保证在意外断电时磁头能靠弹簧力自动离开盘片半径范围，迅速返回停靠架。所以要让硬盘运行时磁头保持在盘片的半径之内，就要使磁头臂驱动电机（寻道电机）持续通以电流。而让磁头臂在硬盘空闲几分钟后就立即执行卸载动作，返回到停靠架上，既有利于节能，又降低了硬盘受外力冲击导致磁头与盘片接触的概率。虽然再次加载会增加一点寻道时间，但毕竟弊大于利，所以在这类硬盘中磁头的加载/卸载次数会远远大于通电周期计数（0C）或启停计数（04）的数据量。不过这种加载/卸载方式已经没有了磁头与盘片的接触，所以设计值也已大大增加，通常笔记本内置硬盘的磁头加载/卸载额定值在30～60万次，而台式机新型节能硬盘的磁头加载/卸载设计值可达一百万次。
</code></pre><p><font color="#dd0000">C2h(194) Temperature 温度</font><br></p>
<pre><code>这个数值直接表示了硬盘内部的当前温度。硬盘运行时最好不要超过45℃，温度过高虽不会导致数据丢失，但引起的机械变形会导致寻道与读写错误率上升，降低硬盘性能。硬盘的最高允许运行温度可查看硬盘厂商给出的数据，一般不会超过60℃。
</code></pre><p>C3h(195) Hardware ECC Recovered  </p>
<pre><code>这个数值记录了磁头在盘片上读写时通过ECC技术校正错误的次数，不过许多硬盘有其制造商特定的数据结构，因此数据量的大小并不能直接说明问题。
</code></pre><p>C4h(196) Reallocation Event Count 重映射事件计数</p>
<pre><code>数据值应为0，当前值应该远大于临界值。

记录已重映射操作的计数，无论是否成功转移，都会被计数。反映了硬盘已经存在了不良扇区。
</code></pre><p><font color="#dd0000">C5h(197) Current Pending Sector Count 当前待映射扇区计数</font><br></p>
<pre><code>数据值应为0，当前值应该远大于临界值。

记录了不稳定的扇区的数量，即等待被映射的扇区。如果不稳定扇区在随后的读写中成功了，那么此扇区就不再列入等待的范围，数值会下降。仅仅读取时出错的扇区并不会导致重映射，只是被列入“等待”，也许以后读取就没有问题，所以只有在写入失败时才会发生重映射。下次对该扇区写入时如果继续出错，就会产生一次重映射操作，此时重映射扇区计数（05）与重映射事件计数（C4）的数据值增加，此参数的数据值下降。
</code></pre><p><font color="#dd0000">C6h(198) Offline Uncorrectable Sector Count 脱机无法校正的扇区计数</font><br></p>
<pre><code>数据应为0，当前值应远大于临界值。 

这个参数的数据累计了读写扇区时发生的无法校正的错误总数。数值上升表明盘片表面介质或机械子系统出现问题，有些扇区肯定已经不能读取，如果有文件正在使用这些扇区，操作系统会返回读盘错误的信息。下一次写操作时会对该扇区执行重映射。
</code></pre><p><font color="#dd0000">C7h(199) UDMA CRC Error CountULTRA DMA访问校验错误率</font><br></p>
<p><font color="#dd0000">C7h(199) Ultra ATA CRC Error Rate  Ultra DMA访问校验错误率</font><br></p>
<pre><code>这个参数的数据值累计了通过接口循环冗余校验（Interface Cyclic Redundancy Check，ICRC）发现的数据线传输错误的次数。如果数据值不为0且持续增长，表示“硬盘控制器→数据线→硬盘接口”出现错误，劣质的数据线、接口接触不良都可能导致此现象。由于这一项的数据值不会复零，所以某些新硬盘也会出现一定的数据量，只要更换数据线后数值不再继续增长，即表示问题已得到解决。
</code></pre><p>C8h(200) Multi-zone Error Rate 多区域错误率</p>
<p><font color="#dd0000">C8h(200) Write Error Rate 写入错误率</font><br></p>
<pre><code>数据应为0，当前值应远大于临界值。  

这个参数的数据累计了向扇区写入数据时出现错误的总数。有的新硬盘也会有一定的数据量，若数值持续快速升高（当前值偏低），表示盘片、磁头组件可能有问题。  
</code></pre><p>CEh(206) Flying Height 磁头飞行高度</p>
<pre><code>磁头距离盘片表面的垂直距离。高度过低则增加了磁头与盘片接触导致损坏的可能性；高度偏高则增大了读写错误率。不过准确地说，硬盘中并没有任何装置可以直接测出磁头的飞行高度，制造商也只是根据磁头读取的信号强度来推算磁头飞行高度。
</code></pre><p>CFh(207) Spin High Current 主轴过电流</p>
<pre><code>数值记录了主轴电机运行时出现浪涌电流的次数，数据量的增加意味着轴承或电机可能有问题。
</code></pre><p>D0h(208) Spin Buzz 主轴电机重启次数</p>
<pre><code>数值记录了主轴电机反复尝试启动的次数，这通常是由于电源供电不足引起的。
</code></pre><p>DCh(220) Disk Shift 盘片偏移量</p>
<pre><code>硬盘中的盘片相对主轴的偏移量（通常是受外力冲击或温度变化所致），单位未知，数据值越小越好。
</code></pre><p>F1h(241) Total LBAs Written LBA写入总数</p>
<pre><code>LBA写入数的累计。
</code></pre><p>F2h(242) Total LBAs Read LBA读取总数</p>
<pre><code>LBA读取数的累计。某些SMART读取工具会显示负的数据值，是因为采用了48位LBA，而不是32位LBA。
</code></pre><p>FEh(254) Free Fall Protection  自由坠落保护</p>
<pre><code>现在有些笔记本硬盘具有自由坠落保护功能，当硬盘内置的加速度探测装置检测到硬盘位移时，会立即停止读写操作，将磁头臂复位。这个措施防止了磁头与盘片之间发生摩擦撞击，提高了硬盘的抗震性能。这个参数的数据里记录了这一保护装置动作的次数。
</code></pre><h2 id="3-3-SAS-SMART日志示例"><a href="#3-3-SAS-SMART日志示例" class="headerlink" title="3.3 SAS SMART日志示例"></a>3.3 SAS SMART日志示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=== START OF READ SMART DATA SECTION ===</span><br><span class="line">SMART Health Status: OK</span><br><span class="line"></span><br><span class="line">Current Drive Temperature:     31 C</span><br><span class="line">Drive Trip Temperature:        65 C</span><br><span class="line"></span><br><span class="line">Manufactured in week 31 of year 2017</span><br><span class="line">Specified cycle count over device lifetime:  50000</span><br><span class="line">Accumulated start-stop cycles:  21</span><br><span class="line">Specified load-unload count over device lifetime:  600000</span><br><span class="line">Accumulated load-unload cycles:  22</span><br><span class="line">Elements in grown defect list: 0</span><br><span class="line"></span><br><span class="line">Error counter log:</span><br><span class="line">           Errors Corrected by           Total   Correction     Gigabytes    Total</span><br><span class="line">               ECC          rereads/    errors   algorithm      processed    uncorrected</span><br><span class="line">           fast | delayed   rewrites  corrected  invocations   [10^9 bytes]  errors</span><br><span class="line">read:       2155        1         0         0          0       6621.256           0</span><br><span class="line">write:         0        0         0         0          0        177.814           0</span><br><span class="line"></span><br><span class="line">Non-medium error count:        1</span><br><span class="line"></span><br><span class="line">SMART Self-test log</span><br><span class="line">Num  Test              Status                 segment  LifeTime  LBA_first_err [SK ASC ASQ]</span><br><span class="line">     Description                              number   (hours)</span><br><span class="line"># 1  Background long   Completed                   -       4                 - [-   -    -]</span><br><span class="line">Long (extended) Self Test duration: 7411 seconds [123.5 minutes]</span><br></pre></td></tr></table></figure>
<h2 id="3-4-SAS-SMART参数详解"><a href="#3-4-SAS-SMART参数详解" class="headerlink" title="3.4 SAS SMART参数详解"></a>3.4 SAS SMART参数详解</h2><pre><code>SATA和SAS的SMART日志内容格式不一样，ID参数也不一样，但是参数含义大同小异；由于SATA盘的smart信息较全，因此本文档以SATA的参数解释为主，SAS盘的参数解释请参考SATA盘的。

SAS盘的smart信息少，最为直观且重要的一项指标是“Elements in grown defect list”，即Glist。&quot; Error counter log:Total uncorrected errors:&quot;   10就建议更换。

“Non-medium error count” 非介质错误计数。正常是0；一般可能的原因为是电缆、传输、校验问题，可以忽略。
</code></pre><h2 id="3-5-硬盘坏道表PList和GList"><a href="#3-5-硬盘坏道表PList和GList" class="headerlink" title="3.5 硬盘坏道表PList和GList"></a>3.5 硬盘坏道表PList和GList</h2><pre><code>硬盘的数据密度很大，在生产过程中不可避免地会产生缺陷，同时在使用过程中，那些不稳定的扇区也会逐渐老化而产生数据读写错误，这些缺陷和不稳定扇区会严重威胁硬盘数据的安全。为此，硬盘设计了两个坏道表来处理这些有缺陷的扇区，即P-list和G-list，它们用于记录硬盘的缺陷扇区的情况，使硬盘工作时不会在缺陷扇区里读写数据，防止数据损坏。

坏道的产生可以分为两种情况：一是生产过程中产生的缺陷扇区，二是使用过程的产生的缺陷扇区。硬盘设计两个坏道表就是用于分别识别和处理硬盘的两种不同的坏道的。
</code></pre><p>P-list (Primary Defect List) 基本缺陷列表</p>
<pre><code>在每个硬盘在生产的时候，其实不可避免会产生有部分碟片磁介质不均匀，或者有损坏的地区，对于这部分在生产过程中产生的不稳定的扇区，工厂就会使用一个PLIST 来记录下来。
</code></pre><p>P-list叫做“永久缺陷表”，这些记录地址在硬盘运行时候自动被跳过，所以P-list不影响硬盘的存取速度。</p>
<p>G-list (Grown Defect List) 成长缺陷列表</p>
<pre><code> 称为增长坏道表，这些记录地址随着用户使用硬盘，硬盘检测到某些区域可能存在缺陷（坏扇区），自动重新映射到出厂时预留的空间。

用来保护用户数据的访问安全。由于G-list带来的是重映射，而非跳过，也就意味着硬盘首先寻找到坏的区域然后再映射到安全区域，这样就会造成硬盘存取速度的减慢。
</code></pre><h1 id="四、DST硬盘自检"><a href="#四、DST硬盘自检" class="headerlink" title="四、DST硬盘自检"></a>四、DST硬盘自检</h1><pre><code>DST（Drive Self Test），硬盘自测试，通过一定的算法，实现硬盘的诊断和SMART刷新。DST主要分为三种测试类型：Short DST、Long DST(SATA硬盘又称其为Extended Self Test)、Conveyance DST。在DST离线的测试完成后，硬盘会把测试的结果刷新到Self test log。

DST主要包括spindup马达磁头臂起转测试、Buffer RAM/Flash ROM检测、伺服定位功能检测、寻道测试、读写磁头检测、读写校验测试、低级格式化功能检测、碟片缺陷检测，部分厂家的DST还会进行日志事件异常检测以及SMART检测等等。
</code></pre>]]></content>
      <tags>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装文档</title>
    <url>/docker%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<h2 id="有网环境安装"><a href="#有网环境安装" class="headerlink" title="有网环境安装"></a>有网环境安装</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>Docker 运行环境依赖于服务器的内核，它的内核版本要求在 <strong>2.6.32-431</strong> 以上才可以正常运行。</li>
<li>Docker 官方推荐使用的内核为 <strong>3.0</strong> 以上，在该内核上运行 Docker 可以使服务更加稳定，所以在安装 Docker 之前请将服务器内核升级到 <strong>3.0</strong> 版本以上。     </li>
</ul>
<h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><h4 id="使用自动脚本安装Docker-默认安装最新版本docker"><a href="#使用自动脚本安装Docker-默认安装最新版本docker" class="headerlink" title="使用自动脚本安装Docker(默认安装最新版本docker)"></a>使用自动脚本安装Docker(默认安装最新版本docker)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker官方源</span></span><br><span class="line">$ curl -sSL https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># daocloud镜像源</span></span><br><span class="line">$ curl -sSL https://get.daocloud.io/docker | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># aliyun镜像源</span></span><br><span class="line">$ curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从Rancher网站安装指定版本的docker</span></span><br><span class="line">$ curl https://releases.rancher.com/install-docker/1.12.sh | sh</span><br></pre></td></tr></table></figure>
<h4 id="安装指定版本的Docker"><a href="#安装指定版本的Docker" class="headerlink" title="安装指定版本的Docker"></a>安装指定版本的Docker</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-cache madison docker-engine</span><br><span class="line"></span><br><span class="line">docker-engine | 1.13.0-0~ubuntu-xenial | https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages</span><br><span class="line">docker-engine | 1.12.6-0~ubuntu-xenial | https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages</span><br><span class="line">docker-engine | 1.12.5-0~ubuntu-xenial | https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages</span><br><span class="line">docker-engine | 1.12.4-0~ubuntu-xenial | https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages</span><br></pre></td></tr></table></figure>
<p>然后根据版本号进行安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get -y install docker-engine=&lt;VERSION_STRING&gt;</span><br><span class="line"><span class="comment"># 例如安装 1.12.5 ubuntu-trusty 版本</span></span><br><span class="line">$ apt-get --force-yes install docker-engine=1.12.5-0~ubuntu-trusty</span><br></pre></td></tr></table></figure></p>
<p>也可以使用rancher脚本安装，<a href="http://rancher.com/docs/rancher/v1.5/en/hosts/#supported-docker-versions" target="_blank" rel="noopener">参考链接</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://releases.rancher.com/install-docker/&lt;VERSION_STRING&gt;.sh | sh</span><br><span class="line"><span class="comment"># 例如安装 17.03.x-ce 版本</span></span><br><span class="line">$ curl https://releases.rancher.com/install-docker/17.03.sh | sh</span><br></pre></td></tr></table></figure></p>
<h3 id="配置镜像源"><a href="#配置镜像源" class="headerlink" title="配置镜像源"></a>配置镜像源</h3><h4 id="USTC"><a href="#USTC" class="headerlink" title="USTC"></a>USTC</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">echo</span> <span class="string">"DOCKER_OPTS=\"--registry-mirror=https://docker.mirrors.ustc.edu.cn\""</span>&gt;&gt; /etc/default/docker</span><br><span class="line"></span><br><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure>
<h4 id="Daocloud"><a href="#Daocloud" class="headerlink" title="Daocloud"></a>Daocloud</h4><p>DaoCloud也提供了docker加速器，但是跟ustc不同，需要用户注册后才能使用，并且每月限制流量10GB。详情请查看  <a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">配置Daocloud加速器</a>。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://&#123;your_id&#125;.m.daocloud.io</span><br><span class="line">  </span><br><span class="line">$ service docker restart</span><br></pre></td></tr></table></figure></p>
<h4 id="网易163"><a href="#网易163" class="headerlink" title="网易163"></a>网易163</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"DOCKER_OPTS=\"--registry-mirror=http://hub-mirror.c.163.com\""</span>&gt;&gt; /etc/default/docker</span><br><span class="line">  </span><br><span class="line">$ service docker restart</span><br></pre></td></tr></table></figure>
<h3 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h3><p>卸载Docker后，/var/lib/docker/目录下会保留原Docker的镜像，网络，存储卷等文件。如果需要全新安装Docker，需要删除/var/lib/docker/目录。</p>
<h4 id="Ubuntu-Debian"><a href="#Ubuntu-Debian" class="headerlink" title="Ubuntu/Debian"></a>Ubuntu/Debian</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -rf /var/lib/docker/</span><br></pre></td></tr></table></figure>
<h4 id="RHEL-CentOS"><a href="#RHEL-CentOS" class="headerlink" title="RHEL/CentOS"></a>RHEL/CentOS</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">docker-common \</span><br><span class="line">container-selinux \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -rf /var/lib/docker/</span><br></pre></td></tr></table></figure>
<h4 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a>Fedora</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf remove docker \</span><br><span class="line">docker-common \</span><br><span class="line">container-selinux \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -rf /var/lib/docker/</span><br></pre></td></tr></table></figure>
<h2 id="无网环境安装"><a href="#无网环境安装" class="headerlink" title="无网环境安装"></a>无网环境安装</h2><p>我在 github 上对小于 centos6.8 的版本编写了一套 Docker 安装脚本，请点击查看 <a href="https://github.com/zhuqifei1994/docker-install/blob/master/%E6%97%A0%E7%BD%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3.md" target="_blank" rel="noopener">安装文档</a>。</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
